yy2<- curve2(ML2$par[1], ML2$par[2], ML2$par[3], ML2$par[5], ML2$par[6], ML2$par[7],xx)
yy2
yy<- curve(ML1$par[1], ML1$par[2], ML1$par[3],xx)
plot(data[[i]]$distance, data[[i]]$x, type="p", ylim=c(0, ymax), xaxt="n", yaxt="n", xlab="", ylab="", cex=0.8)#
	points(xx, yy2, type="l", col="red", lwd=2)
ymax <- 150
plot(data[[i]]$distance, data[[i]]$x, type="p", ylim=c(0, ymax), xaxt="n", yaxt="n", xlab="", ylab="", cex=0.8)#
	points(xx, yy2, type="l", col="red", lwd=2)
points(xx, yy, type="l", col="green", lwd=2)
axis(2, las=2, at=c(0, ymax*0.25, ymax*0.5, ymax*0.75, ymax), labels=FALSE)#
    axis(1, labels=FALSE, at=c(0, 10, 20, 30, 40))#
	abline(v=exp(MLparam2[[i]]$par[2]))#
	abline(v=exp(MLparam2[[i]]$par[6]))
abline(v=exp(ML2$par[2]))
exp(ML2$par[2]
)
abline(v=ML2$par[2])
abline(v=MLparam2[[i]]$par[6])
abline(v=ML2$par[6])
abline(h=ML2$par[1] + ML2$par[5])
abline(h=ML2$par[1])
abline(h=ML2$par[5])
plotRaw("contrTest2")
plotRaw("contrTest2", maxDist=35)
plotRaw("contrTest2", xmax=35)
plotRaw("contrTest2", xmax=30)
maxLik("contrTest2", twoCurve=TRUE, maxDist=30)
maxLik <- function(data, standardLoc = 0, dotedge=3, maxDist=30, ymax=200, xplots = 6, maxSlope = 20, popUp = TRUE, log=TRUE, nameVector=TRUE, twoCurve=FALSE){#
	projectName <- data#
	fileFolder <- paste(Sys.Date(), projectName, sep="_")#
	dir.create(paste(getwd(), "/figures/", sep=""), showWarnings= FALSE)#
	dir.create(paste(getwd(), "/figures/", fileFolder, sep=""), showWarnings= FALSE)#
	dir.create(paste(getwd(), "/parameter_files/", projectName, sep=""), showWarnings=FALSE)#
#
	data <- eval(parse(text=data))#
	if (is.logical(nameVector)){#
		if (nameVector){label <- names(data)}		#
		else {label <- rep("", length(data))}#
		}#
	else {label <- nameVector}	#
#
#which(data[[i]][,1] > standardLoc)[1]]#
	###The likelihoic part:#
	if (!is.logical(standardLoc)){#
#		dotMax <- max(sapply(data, function(x) {x[standardLoc,2]})) #
		dotMax <- max(sapply(data, function(x) {x[which(x[,1] > standardLoc)[1], 2]})) 		#
#		standMax <-c( sapply(data, function(x) {dotMax-x[standardLoc,2]}))#
		standMax <-c( sapply(data, function(x) {dotMax-x[which(x[,1] > standardLoc)[1], 2]}))#
		}#
	else{#
		standMax <- rep(0, length(data))#
		}#
	if (log){#
		if(twoCurve){#
			ML1 <-lapply(c(1:length(data)), getstatsLog, data=data, dotedge=dotedge, maxDist=maxDist, stand=standMax, maxSlope=maxSlope)#
			ML2 <- lapply(c(1:length(data)), getstats2curve, data=data, dotedge=dotedge, maxDist=maxDist, stand=standMax, maxSlope=maxSlope)#
			}#
		else{#
			ML <-lapply(c(1:length(data)), getstatsLog, data=data, dotedge=dotedge, maxDist=maxDist, stand=standMax, maxSlope=maxSlope)#
		}#
		}	#
	else{#
		ML <-lapply(c(1:length(data)), getstats, data=data, dotedge=dotedge, maxDist=maxDist, stand=standMax, maxSlope=maxSlope)#
		}#
	names(ML) <- names(data)#
	fileName <- paste(Sys.Date(), "_", projectName, sep="")#
#
	if (is.logical(nameVector)){#
		if (nameVector){label <- names(data)}		#
		else {label <- rep("", length(data))}#
		}#
	else {label <- nameVector}#
#
	t <- paste("figures/", Sys.Date(), "_", projectName , "/", projectName, "_MLfit.pdf", sep="")#
	cat(paste("Saving figure: ", t, sep=""))#
	xplots <- xplots#
	if (ceiling(length(data)/xplots) < 6) {#
		yplots<- ceiling(length(data)/xplots)}#
	else {yplots<- 6}#
	numpages <- ceiling(length(data)/(xplots*yplots))#
	pdf(t, width=7, height=6)#
	par(mfrow=c(yplots , xplots), mar=c(1,1,1,1), oma=c(4,5,1,1))#
	if(twoCurve){#
		for (k in 1:length(data)){#
			plotMLCurve2Models(data, ML1, ML2, stand=standMax, i =k, dotedge=dotedge, maxDist=maxDist, ymax=ymax, label=label[k])#
			if(numpages == 1){#
				if (k >= xplots*yplots-xplots+1){#
					axis(1, cex.axis=0.8, at=c(0, 10, 20, 30, 40), labels=c(0, 10, 20, 30, 40))#
					}#
				}#
			if(numpages == 2){#
				if (k >= xplots*yplots-xplots+1 & k < xplots*yplots+1){#
					axis(1, cex.axis=0.8, at=c(0, 10, 20, 30, 40), labels=c(0, 10, 20, 30, 40))#
					}#
				if (k >= 2*xplots*yplots-xplots+1){#
					axis(1, cex.axis=0.8, at=c(0, 10, 20, 30, 40), labels=c(0, 10, 20, 30, 40))#
					}#
				}				#
			if(numpages == 3){#
				if (k >= xplots*yplots-xplots+1 & k < xplots*yplots+1){#
					axis(1, cex.axis=0.8, at=c(0, 10, 20, 30, 40), labels=c(0, 10, 20, 30, 40))#
					}#
				if (k >= 2*xplots*yplots-xplots+1 & k < 2*xplots*yplots+1){#
					axis(1, cex.axis=0.8, at=c(0, 10, 20, 30, 40), labels=c(0, 10, 20, 30, 40))#
					}#
				if (k >= 3*xplots*yplots-xplots+1){#
					axis(1, cex.axis=0.8, at=c(0, 10, 20, 30, 40), labels=c(0, 10, 20, 30, 40))#
					}#
				}				#
#
			j <- 1#
			while (j <= numpages){#
				if (k %in% seq(1, j*yplots*xplots, by=xplots)) {axis(2, cex.axis=0.8, las=2)}#
				j <- j+1#
				}#
			}#
		}#
#
	if(!twoCurve){	#
		if(log){#
			for (k in 1:length(data)){#
				plotRawMLCurveLog(data, ML, stand=standMax, i =k, dotedge=dotedge, maxDist=maxDist, ymax=ymax, label=label[k])#
				if(numpages == 1){#
					if (k >= xplots*yplots-xplots+1){#
						axis(1, cex.axis=0.8, at=c(0, 10, 20, 30, 40), labels=c(0, 10, 20, 30, 40))#
						}#
					}#
				if(numpages == 2){#
					if (k >= xplots*yplots-xplots+1 & k < xplots*yplots+1){#
						axis(1, cex.axis=0.8, at=c(0, 10, 20, 30, 40), labels=c(0, 10, 20, 30, 40))#
						}#
					if (k >= 2*xplots*yplots-xplots+1){#
						axis(1, cex.axis=0.8, at=c(0, 10, 20, 30, 40), labels=c(0, 10, 20, 30, 40))#
						}#
					}				#
				if(numpages == 3){#
					if (k >= xplots*yplots-xplots+1 & k < xplots*yplots+1){#
						axis(1, cex.axis=0.8, at=c(0, 10, 20, 30, 40), labels=c(0, 10, 20, 30, 40))#
						}#
					if (k >= 2*xplots*yplots-xplots+1 & k < 2*xplots*yplots+1){#
						axis(1, cex.axis=0.8, at=c(0, 10, 20, 30, 40), labels=c(0, 10, 20, 30, 40))#
						}#
					if (k >= 3*xplots*yplots-xplots+1){#
						axis(1, cex.axis=0.8, at=c(0, 10, 20, 30, 40), labels=c(0, 10, 20, 30, 40))#
						}#
					}				#
#
				j <- 1#
				while (j <= numpages){#
					if (k %in% seq(1, j*yplots*xplots, by=xplots)) {axis(2, cex.axis=0.8, las=2)}#
					j <- j+1#
					}#
			}#
		}#
	}#
	else{#
		for (k in 1:length(data)){#
			plotRawMLCurve(data, ML, stand=standMax, i =k, dotedge=dotedge, maxDist=maxDist, ymax=ymax, label=label)#
		if(numpages == 1){#
				if (k >= xplots*yplots-xplots+1){#
					axis(1, cex.axis=0.8, at=c(0, 10, 20, 30, 40), labels=c(0, 10, 20, 30, 40))#
					}#
				}#
			if(numpages == 2){#
				if (k >= xplots*yplots-xplots+1 & k < xplots*yplots+1){#
					axis(1, cex.axis=0.8, at=c(0, 10, 20, 30, 40), labels=c(0, 10, 20, 30, 40))#
					}#
				if (k >= 2*xplots*yplots-xplots+1){#
					axis(1, cex.axis=0.8, at=c(0, 10, 20, 30, 40), labels=c(0, 10, 20, 30, 40))#
					}#
				}				#
			if(numpages == 3){#
				if (k >= xplots*yplots-xplots+1 & k < xplots*yplots+1){#
					axis(1, cex.axis=0.8, at=c(0, 10, 20, 30, 40), labels=c(0, 10, 20, 30, 40))#
					}#
				if (k >= 2*xplots*yplots-xplots+1 & k < 2*xplots*yplots+1){#
					axis(1, cex.axis=0.8, at=c(0, 10, 20, 30, 40), labels=c(0, 10, 20, 30, 40))#
					}#
				if (k >= 3*xplots*yplots-xplots+1){#
					axis(1, cex.axis=0.8, at=c(0, 10, 20, 30, 40), labels=c(0, 10, 20, 30, 40))#
					}#
				}				#
#
			j <- 1#
			while (j <= numpages){#
				if (k %in% seq(1, j*yplots*xplots, by=xplots)) {axis(2, cex.axis=0.8, las=2)}#
				j <- j+1#
				}#
		}#
	}	#
#
	mtext("Distance from edge of disc", outer=TRUE, side=1, line=2, cex=1.2)#
	mtext("Pixel density", outer=TRUE, side=2, line=1.5, cex=1.2)#
	dev.off()#
#
	if(popUp){#
		tt <- paste("open", t)#
		system(tt)#
	}#
	cat(paste("\n", projectName, ".ML has been written to the global environment", sep=""))#
	assign(paste(projectName, ".ML", sep=""), ML, envir=globalenv())#
}#
##################################################################################
#FUNCTIONS REQUIRED FOR createDataframe#
#[haloParam] uses the results of MLparam to fit the minHalo and MIC#
#[CI.generalNest] is used twice, once for IC50 and once for slope to find confidence intervals#
#The dataframe is written onto the hard drive#
##################################################################################
haloParam <- function(data, MLparam, dotedge, maxDist, standardLoc, percentileHigh, percentileLow){#
	MIC <- c()#
	minHalo <- c()#
	temp <- list()#
	dotMax <- max(sapply(data, function(x) {x[which(x[,1] > standardLoc)[1], 2]})) 		#
	stand <-c( sapply(data, function(x) {dotMax-x[which(x[,1] > standardLoc)[1], 2]}))#
	for (i in 1:length(MLparam)){#
		startX <- which(data[[i]][,1] > dotedge+0.5)[1]#
		stopX <- which(data[[i]][,1] > maxDist - 0.5)[1]#
		data[[i]] <- data[[i]][startX:stopX, 1:2]#
		data[[i]] <- subset(data[[i]], x != "NA")#
		data[[i]]$x <- data[[i]]$x+ stand[i] -min(data[[i]]$x+stand[i])  #the micel only fits when it goes down to 0#
		data[[i]]$distance <- data[[i]]$distance - (dotedge+0.5)	#
		MIC[i] <- data[[i]][,"distance"][which.max(data[[i]][,"x"] > MLparam[[i]]$par[1]*percentileHigh)]#
		minHalo[i] <- data[[i]][,"distance"][which.max(data[[i]][,"x"] > MLparam[[i]]$par[1]*percentileLow)]#
		# MIC[i]<- xx[which.max(yy > ((MLparams[[i]]$par[1])*0.8))]#
		# minHalo[i]<- xx[which.max(yy > ((MLparams[[i]]$par[1])*0.2))]#
	}#
	temp <- list(MIC, minHalo)#
	return (temp)#
	}	#
#
CI.generalNest <- function(data, MLparam, CI.param, dotedge, maxDist, standardLoc, xplots, showNum, projectName, popUp, makePlot){#
	param <- deparse(substitute(CI.param))#
	tparam <- strsplit(as.character(param), "getCI.")[[1]][2]	#
	if(makePlot){#
		t <- paste("figures/", Sys.Date(), "_", projectName , "/", Sys.Date(), "_", projectName, "_logLik", tparam, ".pdf", sep="")#
		pdf(t, width=7, height=6)#
		xplots <- xplots#
		yplots<-ceiling(length(data)/xplots)#
		par(mfrow=c(yplots , xplots), mar=c(1,3,1,1), oma=c(4,5,1,1))#
	}#
	CI <- lapply(c(1:length(data)), CI.param, dotedge=dotedge, maxDist=maxDist, standardLoc = standardLoc, showNum=showNum, xplots = xplots, yplots = yplots, makePlot=makePlot, MLparam = MLparam, data = data)#
	if(makePlot){#
		dev.off()#
		if(popUp){#
			tt <- paste("open", t)#
			system(tt)#
		}#
	}#
	CI <- CI.assign(CI)#
	CI#
	}#
#
getCI.ic <-function(i, data, lnLik, MLparam, dotedge, maxDist, standardLoc,  showNum, xplots, yplots, makePlot){#
	dotMax <- max(sapply(data, function(x) {x[which(x[,1] > standardLoc)[1], 2]})) 		#
	standMax <-c( sapply(data, function(x) {dotMax-x[which(x[,1] > standardLoc)[1], 2]}))#
	startX <- which(data[[i]][,1] > dotedge+0.5)[1]#
	stopX <- which(data[[i]][,1] > maxDist - 0.5)[1]#
	data[[i]] <- data[[i]][startX:stopX, 1:2]#
	data[[i]] <- subset(data[[i]], x != "NA")#
	data[[i]]$x <- data[[i]]$x+ standMax[i] -min(data[[i]]$x+standMax[i])  #the micel only fits when it goes down to 0#
	data[[i]]$distance <- data[[i]]$distance - (dotedge+0.5)#
	sumsquares.fit <- function(theta){#
		asym<-theta[[1]]#
		ic50<-theta[[2]]#
		scal<-theta[[3]]#
		sigma<-theta[[4]]#
		y<-data[[i]]$x#
		x<-data[[i]]$distance#
		res <- dnorm(y, (asym*exp(scal*(x-ic50))/(1+exp(scal*(x-ic50)))), sigma, log= T) #
		sum(res)#
	}#
	lnLik <- c(unlist(lapply(MLparam, function(x) as.numeric(as.character(unlist(x)[5])))))#
	mli <- lnLik[i]#
#
	highic <- max(data[[i]]$x)#
	IC <- seq(0.1, max(data[[i]]$distance), length=200)#
	asyms <- lapply(data, function(x) min(x$x))#
	MLpars <- MLparam[[i]]$par#
#
	findLLProb <- function(icC) {#
		find.mle(sumsquares.fit,c(MLpars[1], icC, MLpars[3],  MLpars[4]), methic="subplex", upper=c(MLpars[1]+0.0000001, icC+0.0000001, MLpars[3]+0.0000001, MLpars[4]+0.0000001), lower=c(MLpars[1], icC, MLpars[3], MLpars[4]))#
	}#
	testing<-sapply(ic, findLLProb)#
	testing <- unlist(testing[2,])#
	if (max(testing) > mli) {mli <- max(testing)}#
	if(length(which(ll<-(testing>(mli - qchisq(0.95, 1)/2))))>0){#
		bottom <- min(which(ll<-(testing>(mli - qchisq(0.95, 1)/2)))) - 1#
		top <- max(which(ll<-(testing>(mli - qchisq(0.95, 1)/2)))) + 1#
		}#
	if(length(which(ll<-(testing>(mli - qchisq(0.95, 1)/2))))==0){#
		bottom <- 0#
		top <-length(ic)#
		}#
	if(makePlot){		#
		plot(testing, xaxt="n", yaxt="n", xaxt="n")#
		axis(2, las=2, cex.axis=0.6)#
		if (i >= xplots*yplots-xplots+1){axis(1, cex.axis=0.8, at=c(0, 100, 200))}#
		mtext(names(data[i]), side=3, cex=0.8)#
		abline(h=mli)#
		abline(v=top)#
		abline(v=bottom)#
	}#
	return (list(liks = testing, critVals = c(bottom, top), CI = c(ic[[if(bottom<1) 1 else bottom]],  		ic[[if(top>=length(ic)) length(ic) else top]])))#
}#
#
getCI.icLog <-function(i, data, lnLik, MLparam, dotedge, maxDist, standardLoc,  showNum, xplots, yplots, makePlot){#
	dotMax <- max(sapply(data, function(x) {x[which(x[,1] > standardLoc)[1], 2]})) 		#
	stand <-c( sapply(data, function(x) {dotMax-x[which(x[,1] > standardLoc)[1], 2]}))#
	startX <- which(data[[i]][,1] > dotedge+0.5)[1]#
	stopX <- which(data[[i]][,1] > maxDist - 0.5)[1]#
	data[[i]] <- data[[i]][startX:stopX, 1:2]#
	data[[i]] <- subset(data[[i]], x != "NA")#
	data[[i]]$x <- data[[i]]$x+ stand[i] -min(data[[i]]$x+stand[i])  #the micel only fits when it goes down to 0#
	data[[i]]$distance <- data[[i]]$distance - (dotedge+0.5)#
	data[[i]]$distance <- log(data[[i]]$distance)#
	sumsquares.fit <- function(theta){#
		asym<-theta[[1]]#
		ic50<-theta[[2]]#
		scal<-theta[[3]]#
		sigma<-theta[[4]]#
		y<-data[[i]]$x#
		x<-data[[i]]$distance#
		res <- dnorm(y, (asym*exp(scal*(x-ic50))/(1+exp(scal*(x-ic50)))), sigma, log= T) #
		sum(res)#
	}#
	lnLik <- c(unlist(lapply(MLparam, function(x) as.numeric(as.character(unlist(x)[5])))))#
	mli <- lnLik[i]#
#
	highIC <- max(data[[i]]$x)#
	ic <- seq(0.1, max(data[[i]]$distance), length=500)#
	asyms <- lapply(data, function(x) min(x$x))#
	MLpars <- MLparam[[i]]$par#
#
	findLLProb <- function(icC) {#
		find.mle(sumsquares.fit,c(MLpars[1], icC, MLpars[3],  MLpars[4]), methic="subplex", upper=c(MLpars[1]+0.0000001, icC+0.0000001, MLpars[3]+0.0000001, MLpars[4]+0.0000001), lower=c(MLpars[1], icC, MLpars[3], MLpars[4]))#
	}#
	testing<-sapply(ic, findLLProb)#
	testing <- unlist(testing[2,])#
	if (max(testing) > mli) {mli <- max(testing)}#
	if(length(which(ll<-(testing>(mli - qchisq(0.95, 1)/2))))>0){#
		bottom <- min(which(ll<-(testing>(mli - qchisq(0.95, 1)/2)))) - 1#
		top <- max(which(ll<-(testing>(mli - qchisq(0.95, 1)/2)))) + 1#
		}#
	if(length(which(ll<-(testing>(mli - qchisq(0.95, 1)/2))))==0){#
		bottom <- 0#
		top <-length(ic)#
		}#
	if(makePlot){		#
		plot(testing, xaxt="n", yaxt="n", xaxt="n")#
		axis(2, las=2, cex.axis=0.6)#
		if (i >= xplots*yplots-xplots+1){axis(1, cex.axis=0.8, at=c(0, 100, 200))}#
		mtext(names(data[i]), side=3, cex=0.8)#
		abline(h=mli)#
		abline(v=top)#
		abline(v=bottom)#
	}#
	return (list(liks = testing, critVals = c(bottom, top), CI = c(ic[[if(bottom<1) 1 else bottom]],  		ic[[if(top>=length(ic)) length(ic) else top]])))#
}#
#
getCI.slope <- function(i, data, lnLik, MLparam, dotedge, maxDist, standardLoc,  showNum, xplots, yplots, makePlot){#
	dotMax <- max(sapply(data, function(x) {x[which(x[,1] > standardLoc)[1], 2]})) 		#
	stand <-c( sapply(data, function(x) {dotMax-x[which(x[,1] > standardLoc)[1], 2]}))#
	startX <- which(data[[i]][,1] > dotedge+0.5)[1]#
	stopX <- which(data[[i]][,1] > maxDist - 0.5)[1]#
	data[[i]] <- data[[i]][startX:stopX, 1:2]#
	data[[i]] <- subset(data[[i]], x != "NA")#
	data[[i]]$x <- data[[i]]$x+ stand[i] -min(data[[i]]$x+stand[i])  #the micel only fits when it goes down to 0#
	data[[i]]$distance <- data[[i]]$distance - (dotedge+0.5)#
	sumsquares.fit <- function(theta){#
		asym<-theta[[1]]#
		ic50<-theta[[2]]#
		scal<-theta[[3]]#
		sigma<-theta[[4]]#
		y<-data[[i]]$x#
		x<-data[[i]]$distance#
		res <- dnorm(y, (asym*exp(scal*(x-ic50))/(1+exp(scal*(x-ic50)))), sigma, log= T) #
		sum(res)#
	}#
	lnLik <- c(unlist(lapply(MLparam, function(x) as.numeric(as.character(unlist(x)[5])))))#
	mli <- lnLik[i]#
	MLpars <- MLparam[[i]]$par#
#
	scal <- seq(0.0001, 10, length= 500)	#
	asyms <- lapply(data, function(x) min(x$x))#
	lowIC <- 0#
	highIC <- max(data[[i]]$x)+10#
	findLLProb <- function(scalC) {#
		find.mle(sumsquares.fit,c(MLpars[1], MLpars[2], scalC,  MLpars[4]), methic="subplex",upper=c(MLpars[1]+0.000001, MLpars[2]+0.000001, scalC+0.000001, MLpars[4]+0.000001),lower=c(MLpars[1], MLpars[2], scalC, MLpars[4]))#
	}#
#
	testing<-sapply(scal, findLLProb)#
	testing <- unlist(testing[2,])#
	if (max(testing) > mli) {mli <- max(testing)}#
	bottom<-min(which(ll<-(testing>(mli - qchisq(0.95, 1)/2)))) - 1#
	if (bottom=="Inf") { bottom <- 0}#
	top<-max(which(ll<-(testing>(mli - qchisq(0.95, 1)/2)))) + 1#
	if (top=="-Inf") {top <-401}#
	if(makePlot){		#
		plot(testing, xaxt="n", yaxt="n", xaxt="n")#
		axis(2, las=2, cex.axis=0.6)#
		if (i >= xplots*yplots-xplots+1){axis(1, cex.axis=0.8, at=c(0, 100, 200))}#
		mtext(names(data[i]), side=3, cex=0.8)#
		abline(h=mli)#
		abline(v=top)#
		abline(v=bottom)#
	}#
	return(list(liks = testing, critVals = c(bottom, top), CI = c(scal[[if(bottom<1) 1 else bottom]],  scal[[if(top>=length(scal)) length(scal) 	else top]])))#
}#
getCI.slopeLog <- function(i, data, lnLik, MLparam, dotedge, maxDist, standardLoc,  showNum, xplots, yplots, makePlot){#
	dotMax <- max(sapply(data, function(x) {x[which(x[,1] > standardLoc)[1], 2]})) 		#
	stand <-c( sapply(data, function(x) {dotMax-x[which(x[,1] > standardLoc)[1], 2]}))#
	startX <- which(data[[i]][,1] > dotedge+0.5)[1]#
	stopX <- which(data[[i]][,1] > maxDist - 0.5)[1]#
	data[[i]] <- data[[i]][startX:stopX, 1:2]#
	data[[i]] <- subset(data[[i]], x != "NA")#
	data[[i]]$x <- data[[i]]$x+ stand[i] -min(data[[i]]$x+stand[i])  #the micel only fits when it goes down to 0#
	data[[i]]$distance <- data[[i]]$distance - (dotedge+0.5)#
	data[[i]]$distance <- log(data[[i]]$distance)#
	sumsquares.fit <- function(theta){#
		asym<-theta[[1]]#
		ic50<-theta[[2]]#
		scal<-theta[[3]]#
		sigma<-theta[[4]]#
		y<-data[[i]]$x#
		x<-data[[i]]$distance#
		res <- dnorm(y, (asym*exp(scal*(x-ic50))/(1+exp(scal*(x-ic50)))), sigma, log= T) #
		sum(res)#
	}#
	lnLik <- c(unlist(lapply(MLparam, function(x) as.numeric(as.character(unlist(x)[5])))))#
	mli <- lnLik[i]#
	MLpars <- MLparam[[i]]$par#
#
	scal <- seq(0.0001, 10, length=300)	#
	asyms <- lapply(data, function(x) min(x$x))#
	lowIC <- 0#
	highIC <- max(data[[i]]$x)+10#
	findLLProb <- function(scalC) {#
		find.mle(sumsquares.fit,c(MLpars[1], MLpars[2], scalC,  MLpars[4]), methic="subplex",upper=c(MLpars[1]+0.000001, MLpars[2]+0.000001, scalC+0.000001, MLpars[4]+0.000001),lower=c(MLpars[1], MLpars[2], scalC, MLpars[4]))#
	}#
#
	testing<-sapply(scal, findLLProb)#
	testing <- unlist(testing[2,])#
	if (max(testing) > mli) {mli <- max(testing)}#
	bottom<-min(which(ll<-(testing>(mli - qchisq(0.95, 1)/2)))) - 1#
	if (bottom=="Inf") { bottom <- 0}#
	top<-max(which(ll<-(testing>(mli - qchisq(0.95, 1)/2)))) + 1#
	if (top=="-Inf") {top <-401}#
	if(makePlot){		#
		plot(testing, xaxt="n", yaxt="n", xaxt="n")#
		axis(2, las=2, cex.axis=0.6)#
		if (i >= xplots*yplots-xplots+1){axis(1, cex.axis=0.8, at=c(0, 100, 200))}#
		mtext(names(data[i]), side=3, cex=0.8)#
		abline(h=mli)#
		abline(v=top)#
		abline(v=bottom)#
	}#
	return(list(liks = testing, critVals = c(bottom, top), CI = c(scal[[if(bottom<1) 1 else bottom]],  scal[[if(top>=length(scal)) length(scal) 	else top]])))#
}#
#
CI.assign <- function(exptCI, param){ #
	CI <- lapply(exptCI, function(x) unlist(x$CI))#
	cbind(unlist(lapply(CI, function(x) unlist(x[1]))),  unlist(lapply(CI, function(x) unlist(x[2]))))#
	}#
#
createDataframe <- function(data, dotedge = 3, maxDist = 30, standardLoc = 0, lenType=2, xplots = 6,  percentileHigh = 0.8, percentileLow = 0.2, ic50CI = FALSE, findSlopeCI=FALSE, nameVector=TRUE, showNum=FALSE, popUp=FALSE, typeVector=TRUE, log=TRUE, makePlot=FALSE){#
	cat("\nDoing all the things: ")#
	projectName <- data#
	data <- eval(parse(text=projectName))#
	tempML <- paste(projectName, ".ML", sep="")#
	MLparam <- eval(parse(text=tempML))#
	# newdira <- paste(getwd(), "/files/", sep="")#
	newdir <- paste(getwd(), "/parameter_files/", sep="")#
	newdir2 <- paste(getwd(), "/parameter_files/", Sys.Date(), "_", projectName, "/", sep="")#
#
	# newdir <- paste(getwd(), "/files/parameter_files/", sep="")#
	# newdir2 <- paste(getwd(), "/files/parameter_files/", Sys.Date(), "_", projectName, "/", sep="")#
	newdir3 <- paste(getwd(), "/figures/", Sys.Date(), "_", projectName, "/", sep="")#
	filename <- paste(getwd(), "/parameter_files/", Sys.Date(), "_", projectName, "/",  projectName, "_df.csv", sep="")#
	# if (!file.exists(newdira)){		#
		# dir.create(newdira, showWarnings = FALSE)#
		# cat(paste("\n\tCreating new directory: ", newdira), sep="")#
		# }#
	if (!file.exists(newdir)){		#
		dir.create(newdir, showWarnings = FALSE)#
		cat(paste("\n\tCreating new directory: ", newdir), sep="")#
		}#
	if (!file.exists(newdir2)){		#
		dir.create(newdir2, showWarnings = FALSE)#
		cat(paste("\n\tCreating new directory: ", newdir2), sep="")#
		}#
	if (!file.exists(newdir3)){		#
		dir.create(newdir3, showWarnings = FALSE)#
		cat(paste("\n\tCreating new directory: ", newdir3), sep="")#
		}#
	cat("\n\tObtaining asymptote, tolerance, MIC and slope from ML parameters")#
	ic50 <- c(unlist(lapply(MLparam, function(x) as.numeric(as.character(unlist(x)[2])))))#
	slope <- c(unlist(lapply(MLparam, function(x) as.numeric(as.character(unlist(x)[3])))))	#
	asym <- c(unlist(lapply(MLparam, function(x) as.numeric(as.character(unlist(x)[3])))))	#
#
	cat("\n\tCalculating minHalo and maxHalo")#
	haloS <- haloParam(data=data, MLparam=MLparam, dotedge = dotedge, maxDist = maxDist, standardLoc= standardLoc, percentileHigh = percentileHigh, percentileLow = percentileLow)#
	MIC <- c(unlist(haloS[[1]]))#
	minHalo <- c(unlist(haloS[[2]]))#
	if (log){#
		cat("\n\tPutting together dataframe using ln(distance)")#
		df <- data.frame(row.names = seq(1, length(data)), ic50 = round(exp(ic50), digits=2),  slope = round(slope, digits=2), MIC= round(MIC, digits=2), minHalo = round(minHalo, digits=2),  dist=round((MIC - minHalo), digits=2))#
		}#
	else{#
		cat("\n\tPutting together dataframe")#
		df <- data.frame(row.names = seq(1, length(MLparam)), ic50 =  round(ic50, digits=2),  slope = round(slope, digits=2), MIC= round(MIC, digits=2), minHalo = round(minHalo, digits=2), dist=round((MIC - minHalo), digits=2))#
		}#
	if(ic50CI){#
		cat("\n\tFinding ic50 confidence intervals")#
		if (log){#
			cat(" using ln(distance)")#
			icCI <-  CI.generalNest(data=data, MLparam=MLparam,  CI.param= getCI.icLog, dotedge = dotedge, maxDist = maxDist, standardLoc= standardLoc, xplots = xplots, showNum=showNum, projectName= projectName, popUp=popUp, makePlot=makePlot)#
		}#
		else{#
			icCI <-  CI.generalNest(data=data, MLparam=MLparam,  CI.param= getCI.ic, dotedge = dotedge, maxDist = maxDist, standardLoc= standardLoc, xplots = xplots, showNum=showNum, projectName= projectName, popUp=popUp, makePlot=makePlot)	#
		}#
	}#
#
	if(findSlopeCI){#
		cat("\n\tFinding slope confidence intervals")#
		if (log){#
			cat(" using ln(distance)")#
			slopeCI <-  CI.generalNest(data = data, MLparam = MLparam, CI.param= getCI.slopeLog, dotedge = dotedge, maxDist = maxDist,  standardLoc= standardLoc,xplots =xplots, showNum=shownNum, projectName = projectName, popUp=popUp, makePlot=makePlot)		#
		}#
		else{#
			slopeCI <-  CI.generalNest(data = data, MLparam = MLparam, CI.param= getCI.slope, dotedge = dotedge, maxDist = maxDist,  standardLoc= standardLoc,xplots =xplots, showNum=shownNum, projectName = projectName, popUp=popUp, makePlot=makePlot)#
		}#
	}#
	if (ic50CI ==TRUE & findSlopeCI == TRUE){#
		if(log){#
			df <- data.frame(df, ic.cil = round(exp(icCI[,1]), digits=2), ic.cih = round(exp(icCI[,2]), digits=2),  slope.cil = round(slopeCI[,1], digits=2), slope.cih = round(slopeCI[,2], digits=2))#
			}#
		else {df <- data.frame(df, ic.cil = round(icCI[,1], digits=2), ic.cih = round(icCI[,2], digits=2),  slope.cil = round(slopeCI[,1], digits=2), slope.cih = round(slopeCI[,2], digits=2))#
			}#
		}#
	if (ic50CI ==TRUE & findSlopeCI == FALSE){ #
		if (log){#
			df <- data.frame(df, ic.cil = round(exp(icCI[,1]), digits=2), ic.cih = round(exp(icCI[,2]), digits=2))#
			}#
		else {df <- data.frame(df, round(ic.cil = icCI[,1], digits=2), ic.cih = round(icCI[,2], digits=2))#
			}#
	}#
	if (ic50CI ==FALSE & findSlopeCI == TRUE){ #
			df <- data.frame(df, slope.cil = round(slopeCI[,1], digits=2), slope.cih = round(slopeCI[,2], digits=2))#
	}#
	if (is.logical(nameVector)){#
		if (nameVector){#
			cat("\n\tAssigning line names based on photo names")#
			lines <- unlist(lapply(names(data), function(x) strsplit(x, "_")[[1]][1]))#
			df <- data.frame(lines, df)#
			}#
		if (!nameVector){#
			lines <- seq(1, length(data))#
			df <- data.frame(lines, df)	#
		}#
	}#
	if (!is.logical(nameVector)){#
		cat("\n\tAssigning line names based on user-input")#
		lines <- nameVector#
		names <- unlist(lapply(names(data), function(x) strsplit(x, "_")[[1]][1]))#
		df <- data.frame(names=names, lines=lines, df)	#
		}#
#
	if (is.logical(typeVector)){#
		if (typeVector){	#
				type <- unlist(lapply(names(data), function(x) strsplit(x, "_")[[1]][lenType]))#
				cat(paste("\n\tThere were ", length(unique(type)), " unique types found in dataset:", paste(unique(type), collapse=", ")))#
				df <- data.frame(df, type)#
			}#
		else {#
				type <- 1#
				df <- data.frame(df, type)#
			}#
		}#
	if(!is.logical(typeVector)){#
		type <- typeVector#
		df <- data.frame(df, type)#
		}#
	write.csv(df, file=filename, row.names=FALSE)	#
#
	dfName <- paste(projectName, ".df", sep="")#
	cat("\n")#
	cat(paste("\n\t", dfName, " has been written to the global environment", sep=""))#
	cat(paste("\n\tSaving file: ", filename,  sep=""))#
	cat(paste("\n\t", projectName, "_df.csv can be opened in MS Excel.  Save as .xls file if desired.",  sep=""))#
	assign(dfName, df, envir=globalenv())#
	}#
#############################################
#FUNCTIONS REQUIRED FOR aggregateData#
#############################################
aggregateData <- function(projectName, replicate = c("lines", "type"), identifier="default", order="default"){#
	dataframe <- eval(parse(text=paste(projectName, ".df", sep="")))#
	dataframe$slope <- 1/dataframe$slope#
	temp <- aggregate(c(dataframe[c("ic50", "MIC", "minHalo", "dist","slope")]), dataframe[replicate], mean)#
	temp$se.ic50 <- aggregate(c(dataframe[c("ic50")]), dataframe[replicate], se)$ic50#
	temp$se.MIC <- aggregate(c(dataframe[c("MIC")]), dataframe[replicate], se)$MIC#
	temp$se.minHalo <- aggregate(c(dataframe[c("minHalo")]), dataframe[replicate], se)$minHalo#
	temp$se.slope <- aggregate(c(dataframe[c("slope")]), dataframe[replicate], se)$slope#
	temp$se.dist <- aggregate(c(dataframe[c("dist")]), dataframe[replicate], se)$dist#
	if(order == "default"){#
		temp <- temp[order(temp$lines),] #
		}#
	filename <- paste(getwd(), "/parameter_files/", Sys.Date(), "_", projectName, "/",  projectName, "_ag.csv", sep="")#
	newdir2 <- paste(getwd(), "/parameter_files/", sep="")		#
	newdir3 <- paste(getwd(), "/parameter_files/", Sys.Date(), "_", projectName, "/", sep="")	#
#
	dir.create(newdir2, showWarnings = FALSE)#
	dir.create(newdir3, showWarnings = FALSE)#
#
	write.csv(temp, file=filename, row.names=FALSE)	#
	agName <- paste(projectName, ".ag", sep="")#
	cat(paste("\n", agName, " has been written to the global environment", sep=""))#
	cat(paste("\n\nSaving file: ", filename, sep=""))#
	cat(paste("\n",  projectName, "_ag.csv can be opened in MS Excel (save as .xls file if desired)",  sep=""))#
	assign(agName, temp, envir=globalenv())#
	}#
#
#############################################
#FUNCTIONS REQUIRED FOR readExistingDF#
#############################################
readExistingDF <- function(projectName, mean=FALSE, projectFolder=FALSE, dataframeFolder = FALSE){#
	if (projectFolder==FALSE){#
		projectFolder <- tk_choose.dir(caption = "Select location of project folder")#
	}#
	setwd(projectFolder)#
	if (dataframeFolder==FALSE){#
		dataframeFolder <- tk_choose.dir(caption = "Select location of folder with dataframe")#
	}#
	else {projectFolder <- projectFolder}#
	if (mean==FALSE){#
		dfName <- paste(projectName, "_df.csv", sep="")#
		t <- read.csv(paste(dataframeFolder,"/", dfName, sep=""))#
		df <- paste(projectName, ".df", sep="")	#
	}#
	else {#
		dfName <- paste(projectName, "_ag.csv", sep="")#
		t <- read.csv(paste(dataframeFolder,"/", dfName, sep=""))#
		df <- paste(projectName, ".ag", sep="")	#
	}#
	assign(df, t, envir=globalenv())	#
	fileFolder <- paste(Sys.Date(), projectName, sep="_")#
	dir.create(paste(projectFolder, "/figures/", fileFolder, sep=""), showWarnings= FALSE)#
	cat(paste(df, "now present in working directory"))#
}#
#
##################################################
#FUNCTIONS REQUIRED FOR basicPlots#
#these plots reply on multiple individuals functions#
#[plotHaloU] plot the minHalo parameter#
#[plotic50U] plot the ic50 parameter#
#[plotMICU] plot the MIC parameter#
#[plotSlope] plot the slope parameter#
##################################################
plotHaloU <- function(df, trait, col, pch, bg=col, round=0, upper="default", mean=FALSE){#
	if (upper=="default"){	#
		upper <- round(max(df$minHalo*1.1), round)+1}#
	plot(as.numeric(as.factor(df$lines)), df$minHalo,  xaxt="n", yaxt="n", ylim=c(upper, -0.5), col=col, bg = bg, pch= pch, xlab="", ylab= "", cex=2, yaxt="n")#
	axis(2, las=2, cex.axis=1.25, at=c(0, upper*0.25, upper*0.5, upper*0.75, upper))#
	if(mean){#
		arrows(as.numeric(as.factor(df$lines)), df$minHalo+df$se.minHalo, as.numeric(as.factor(df$lines)), df$minHalo-df$se.minHalo, length=0)#
		}	#
	}#
#
plotMICU <- function(df, col,  pch=19, bg=col, round=0, upper="default", mean=FALSE){#
 	if (upper=="default"){#
		upper <- round(max(df$MIC*1.1), round)+1}#
 plot(as.numeric(as.factor(df$lines)), df$MIC,  xaxt="n", yaxt="n", ylim=c(upper, -0.5), col=col, bg = bg, pch= pch, xlab="", ylab= "", cex=2, yaxt="n")#
	axis(2, las=2, cex.axis=1.25, at=c(0, upper*0.25, upper*0.5, upper*0.75, upper))#
	if(mean){#
		arrows(as.numeric(as.factor(df$lines)), df$MIC-df$se.MIC, as.numeric(as.factor(df$lines)), df$MIC+df$se.MIC, length=0)#
		}	#
}#
#
 plotic50U <- function(df,  col,   pch=19, bg=col, round=0, upper="default", plotic50CI = TRUE, mean=FALSE){#
	if (upper=="default"){#
		upper <- round(max(data$ic50*1.1), round)+1}#
	plot(as.numeric(as.factor(df$lines)), df$ic50,  xaxt="n", yaxt="n", ylim=c(upper, -0.5), col=col, bg = bg, pch= pch, xlab="", ylab= "", cex=2, yaxt="n")#
	if (!mean){#
		if (plotic50CI){#
			arrows(as.numeric(as.factor(df$lines)), df$ic.cih, as.numeric(as.factor(df$lines)), df$ic.cil, length=0)#
		}#
	}#
	if(mean){#
		if (plotic50CI){#
			arrows(as.numeric(as.factor(df$lines)), df$ic50+df$se.ic50, as.numeric(as.factor(df$lines)), df$ic50-df$se.ic50, length=0)#
		}#
	}		#
	axis(2, las=2, cex.axis=1.25, at=c(0, upper*0.25, upper*0.5, upper*0.75, upper))#
}#
#
plotSlope <- function(df, col,   pch=19, round=0, upperSlope="default", plotSlopeCI=FALSE, mean=FALSE){#
	if (upperSlope =="default"){#
 		upperSlope <- round(max(df["slope"]*1.1), round)+1#
 		}#
	 plot(as.numeric(as.factor(df$lines)), df$slope,  xaxt="n", yaxt="n", ylim=c(0, upperSlope), col=col, bg = col, pch= pch, xlab="", ylab= "", cex=1.5, yaxt="n")#
	axis(2, las=2, cex.axis=1.25, at=c(0, upperSlope*0.25, upperSlope*0.5, upperSlope*0.75, upperSlope))#
	if(!mean){#
		if (plotSlopeCI){			#
			arrows(as.numeric(as.factor(df$lines)), 1/df$slope.cil, as.numeric(as.factor(df$lines)), 1/df$slope.cih, length=0)#
		}#
	}#
	if(mean){#
		arrows(as.numeric(as.factor(df$lines)), df$slope-df$se.slope, as.numeric(as.factor(df$lines)), df$slope+df$se.slope, length=0)		#
		}#
	}#
#
plotDistance <- function(df, col,   pch=19, bg=col, round=0, mean=FALSE, upperDist=20){#
	plot(as.numeric(as.factor(df$lines)), df$dist,  xaxt="n", yaxt="n", ylim=c(0, upperDist), col=col, bg = col, pch= pch, xlab="", ylab= "", cex=1.5, yaxt="n")#
	axis(2, las=2, cex.axis=1.25)#
	if(mean){#
		arrows(as.numeric(as.factor(df$lines)), df$dist-df$se.dist, as.numeric(as.factor(df$lines)), df$dist+df$se.dist, length=0)		}#
}#
#
basicPlots <- function(projectName, colours = c("black", "black"), nameVector ="default", mean = FALSE, upper=32, upperSlope=0.5, upperDist =20, pch = 19, type=TRUE, wide=TRUE, legend=TRUE, legendLoc = c("bottomright", "topright"), legendText = "default"){#
	palette(c(colours))	#
	dev.off()#
#
	newdir1 <- paste(getwd(), "/figures/", sep="")	#
	newdir2 <- paste(getwd(), "/figures/", Sys.Date(), "_", projectName, "/", sep="")#
	if (!file.exists(newdir1)){		#
		dir.create(newdir1, showWarnings = FALSE)#
		print(paste("Creating new directory: ", newdir1), sep="")#
		}#
	if (!file.exists(newdir2)){		#
		dir.create(newdir2, showWarnings = FALSE)#
		print(paste("Creating new directory: ", newdir1), sep="")#
		}#
	if (!mean){#
		data <- eval(parse(text=paste(projectName, ".df", sep="")))#
		if(type==FALSE){#
			data$type <- "1"}	#
		if(!is.logical(type)){#
			data["type"] <- data[type]}#
		plot1 <- paste("figures/", Sys.Date(), "_", projectName , "/", Sys.Date(), "_", projectName, "_discParam.pdf", sep="")#
		plot2 <- paste("figures/", Sys.Date(), "_", projectName , "/", Sys.Date(), "_", projectName, "_discParam2.pdf", sep="")#
		}		#
#
	if (mean==TRUE){#
		data <- eval(parse(text=paste(projectName, ".ag", sep="")))#
		if(type==FALSE){#
			data$type <- "1"}#
		if(!is.logical(type)){#
			data["type"] <- data[type]}	#
		plot1 <- paste("figures/", Sys.Date(), "_", projectName , "/", Sys.Date(), "_", projectName, "_mean_discParam.pdf", sep="")#
		plot2 <- paste("figures/", Sys.Date(), "_", projectName , "/", Sys.Date(), "_", projectName, "_mean_discParam2.pdf", sep="")#
		}#
#
	plotSlopeCI <- "slope.cih" %in% names(data) |  "se.slope"  %in% names(data)#
	plotic50CI <- "ic.cih" %in% names(data) | "se.ic50" %in% names(data)#
#
	if (wide){#
		pdf(plot1, width=8, height=5,  pointsize=12, family="Helvetica")#
		}#
	else{#
		pdf(plot1, width=5, height=5,  pointsize=12, family="Helvetica")#
		}#
	par(mfrow=c(3,1), mar=c(1.5,1,1,1), oma=c(4,5,1,1))#
	plotHaloU(data, col=as.numeric(as.factor(data[,"type"])), round=-1, pch=pch, upper=upper, mean=mean)#
	mtext("start of halo ring", side=3, outer=FALSE, adj=0.05, font=2, cex=1.2)#
	axis(1, at=c(1:length(unique(data$lines))), labels=FALSE, cex.axis=1)#
#
	if(legend){#
		if (legendText[1] != "default"){#
			legend(legendLoc[1], col = unique(as.numeric(as.factor(data[,"type"]))), pch=pch, legend= legendText)#
		}#
		else{#
			legend(legendLoc[1], col = unique(as.numeric(as.factor(data[,"type"]))), pch=pch, legend= unique(data[,"type"]))#
		}#
	}#
#
	plotic50U(data, col=as.numeric(as.factor(data$type)),  pch=pch, round=-1, upper=upper, mean=mean, plotic50CI = plotic50CI )#
	axis(1, at=c(1:length(unique(data$lines))), labels=FALSE, cex.axis=1)#
	mtext("midpoint", side=3, outer=FALSE, adj=0.05, font=2, cex=1)#
	mtext("Distance from dot edge (in mm)", side=2, line=3, cex=1.2, font=2, outer=TRUE)#
	plotMICU(data, col=as.numeric(as.factor(data$type)),  pch=pch, round=-1, upper=upper, mean=mean)#
	if (nameVector =="default"){#
		axis(1, at=c(1:length(unique(data$lines))), labels=unique(data$lines), cex.axis=0.9)}#
	if (nameVector !="default"){#
		axis(1, at=c(1:length(unique(data$lines))), labels=lines, cex.axis=0.9)}#
	mtext("MIC", side=3, outer=FALSE, adj=0.05, font=2, cex=1.2)#
	dev.off()#
	system(paste("open ", plot1, sep=""))#
#
	if (wide){#
	pdf(plot2, width=8, height=6,  pointsize=12, family="Helvetica")#
		}#
	else{#
		pdf(plot2, width=7, height=5,  pointsize=12, family="Helvetica")#
	}#
	par(mfrow=c(2,1), mar=c(1.5,1,1,1), oma=c(4,5,1,1))#
	plotSlope(data, col=as.numeric(as.factor(data[,"type"])),  pch=pch, round=-2, upperSlope=upperSlope, plotSlopeCI=plotSlopeCI, mean=mean)#
	mtext("1/slope ('sensitivity')", side=2, line=4, cex=1.2, font=2, outer=FALSE)#
	axis(1, at=c(1:length(unique(data$lines))), labels=FALSE, cex.axis=1)#
	if(legend){#
		if (legendText[1] != "default"){#
			legend(legendLoc[2], col = unique(as.numeric(as.factor(data[,"type"]))), pch=pch, legend= legendText)#
		}#
		else{#
			legend(legendLoc[2], col = unique(as.numeric(as.factor(data[,"type"]))), pch=pch, legend= unique(data[,"type"]))#
		}#
	}#
	plotDistance(data, col=as.numeric(as.factor(data[,"type"])),  pch=pch, round=-1, mean=mean, upperDist=upperDist)#
	if (nameVector =="default"){#
		axis(1, at=c(1:length(unique(data$lines))), labels=unique(data$lines), cex.axis=0.6)}#
	if (nameVector !="default"){#
		axis(1, at=c(1:length(unique(data$lines))), labels= nameVector, cex.axis=0.6)}#
	mtext("halo ring size (mm) ('tolerance')", side=2, line=4, cex=1.2, font=2, outer=FALSE)	#
	dev.off()#
	system(paste("open ", plot2, sep=""))#
}#
#
##################################################
#FUNCTIONS REQUIRED FOR discAssay#
##################################################
discAssay <- function(name, ymin=0, ymax=200, xmin=0, xmax=250, xplots=6, maxDist = 200, dotedge=22, tomm=5.33, plotDot=TRUE, nameVector=TRUE, lenType = 1, findSlopeCI = FALSE, identifier="default"){#
	runImageJAnalysis(name)#
	plotRaw1rep(name, ymin=ymin, ymax=ymax, xmin=xmin, xmax=xmat, dotedge=dotedge, plotDot=plotDot, nameVector=nameVector, xplots=xplots)#
	maxLik(name, dotedge=dotedge, maxDist=maxDist, ymax=ymax, xplots=xplots)#
	createDataframe(name, dotedge=dotedge, maxDist = maxDist, tomm=tomm, lenType = lenType, nameVector=nameVector, findSlopeCI=findSlopeCI)#
	aggregateData(name, identifier=identifier)#
	}#
#
##################################################
#Info for Aleeza clinical isolates#
##################################################
clinType <- data.frame(clade = c(1, 4, 4, 1, 2, 3, 1, 4, 4, 2, 3, 3, 2, 1, 3, 2), mat = c(1,1,3,3,3,2,2,2,2,2,2,1,1,2,3,2))#
clinCol <- c("dicgerblue3","darkred", "darkorange", "darkgreen")#
clinType2rep <- data.frame(clade = rep(c(1, 4, 4, 1, 2, 3, 1, 4, 4, 2, 3, 3, 2, 1, 3, 2), each=2), mat = rep(c(1,1,3,3,3,2,2,2,2,2,2,1,1,2,3,2), each=2))
maxLik("contrTest2", twoCurve=TRUE, maxDist=30)
maxLik <- function(data, standardLoc = 0, dotedge=3, maxDist=30, ymax=200, xplots = 6, maxSlope = 20, popUp = TRUE, log=TRUE, nameVector=TRUE, twoCurve=FALSE){#
	projectName <- data#
	fileFolder <- paste(Sys.Date(), projectName, sep="_")#
	dir.create(paste(getwd(), "/figures/", sep=""), showWarnings= FALSE)#
	dir.create(paste(getwd(), "/figures/", fileFolder, sep=""), showWarnings= FALSE)#
	dir.create(paste(getwd(), "/parameter_files/", projectName, sep=""), showWarnings=FALSE)#
#
	data <- eval(parse(text=data))#
	if (is.logical(nameVector)){#
		if (nameVector){label <- names(data)}		#
		else {label <- rep("", length(data))}#
		}#
	else {label <- nameVector}	#
#
#which(data[[i]][,1] > standardLoc)[1]]#
	###The likelihoic part:#
	if (!is.logical(standardLoc)){#
#		dotMax <- max(sapply(data, function(x) {x[standardLoc,2]})) #
		dotMax <- max(sapply(data, function(x) {x[which(x[,1] > standardLoc)[1], 2]})) 		#
#		standMax <-c( sapply(data, function(x) {dotMax-x[standardLoc,2]}))#
		standMax <-c( sapply(data, function(x) {dotMax-x[which(x[,1] > standardLoc)[1], 2]}))#
		}#
	else{#
		standMax <- rep(0, length(data))#
		}#
	if (log){#
		if(twoCurve){#
			ML <-lapply(c(1:length(data)), getstatsLog, data=data, dotedge=dotedge, maxDist=maxDist, stand=standMax, maxSlope=maxSlope)#
			ML2 <- lapply(c(1:length(data)), getstats2curve, data=data, dotedge=dotedge, maxDist=maxDist, stand=standMax, maxSlope=maxSlope)#
			}#
		else{#
			ML <-lapply(c(1:length(data)), getstatsLog, data=data, dotedge=dotedge, maxDist=maxDist, stand=standMax, maxSlope=maxSlope)#
		}#
		}	#
	else{#
		ML <-lapply(c(1:length(data)), getstats, data=data, dotedge=dotedge, maxDist=maxDist, stand=standMax, maxSlope=maxSlope)#
		}#
	names(ML) <- names(data)#
	fileName <- paste(Sys.Date(), "_", projectName, sep="")#
#
	if (is.logical(nameVector)){#
		if (nameVector){label <- names(data)}		#
		else {label <- rep("", length(data))}#
		}#
	else {label <- nameVector}#
#
	t <- paste("figures/", Sys.Date(), "_", projectName , "/", projectName, "_MLfit.pdf", sep="")#
	cat(paste("Saving figure: ", t, sep=""))#
	xplots <- xplots#
	if (ceiling(length(data)/xplots) < 6) {#
		yplots<- ceiling(length(data)/xplots)}#
	else {yplots<- 6}#
	numpages <- ceiling(length(data)/(xplots*yplots))#
	pdf(t, width=7, height=6)#
	par(mfrow=c(yplots , xplots), mar=c(1,1,1,1), oma=c(4,5,1,1))#
	if(twoCurve){#
		for (k in 1:length(data)){#
			plotMLCurve2Models(data, ML, ML2, stand=standMax, i =k, dotedge=dotedge, maxDist=maxDist, ymax=ymax, label=label[k])#
			if(numpages == 1){#
				if (k >= xplots*yplots-xplots+1){#
					axis(1, cex.axis=0.8, at=c(0, 10, 20, 30, 40), labels=c(0, 10, 20, 30, 40))#
					}#
				}#
			if(numpages == 2){#
				if (k >= xplots*yplots-xplots+1 & k < xplots*yplots+1){#
					axis(1, cex.axis=0.8, at=c(0, 10, 20, 30, 40), labels=c(0, 10, 20, 30, 40))#
					}#
				if (k >= 2*xplots*yplots-xplots+1){#
					axis(1, cex.axis=0.8, at=c(0, 10, 20, 30, 40), labels=c(0, 10, 20, 30, 40))#
					}#
				}				#
			if(numpages == 3){#
				if (k >= xplots*yplots-xplots+1 & k < xplots*yplots+1){#
					axis(1, cex.axis=0.8, at=c(0, 10, 20, 30, 40), labels=c(0, 10, 20, 30, 40))#
					}#
				if (k >= 2*xplots*yplots-xplots+1 & k < 2*xplots*yplots+1){#
					axis(1, cex.axis=0.8, at=c(0, 10, 20, 30, 40), labels=c(0, 10, 20, 30, 40))#
					}#
				if (k >= 3*xplots*yplots-xplots+1){#
					axis(1, cex.axis=0.8, at=c(0, 10, 20, 30, 40), labels=c(0, 10, 20, 30, 40))#
					}#
				}				#
#
			j <- 1#
			while (j <= numpages){#
				if (k %in% seq(1, j*yplots*xplots, by=xplots)) {axis(2, cex.axis=0.8, las=2)}#
				j <- j+1#
				}#
			}#
		}#
#
	if(!twoCurve){	#
		if(log){#
			for (k in 1:length(data)){#
				plotRawMLCurveLog(data, ML, stand=standMax, i =k, dotedge=dotedge, maxDist=maxDist, ymax=ymax, label=label[k])#
				if(numpages == 1){#
					if (k >= xplots*yplots-xplots+1){#
						axis(1, cex.axis=0.8, at=c(0, 10, 20, 30, 40), labels=c(0, 10, 20, 30, 40))#
						}#
					}#
				if(numpages == 2){#
					if (k >= xplots*yplots-xplots+1 & k < xplots*yplots+1){#
						axis(1, cex.axis=0.8, at=c(0, 10, 20, 30, 40), labels=c(0, 10, 20, 30, 40))#
						}#
					if (k >= 2*xplots*yplots-xplots+1){#
						axis(1, cex.axis=0.8, at=c(0, 10, 20, 30, 40), labels=c(0, 10, 20, 30, 40))#
						}#
					}				#
				if(numpages == 3){#
					if (k >= xplots*yplots-xplots+1 & k < xplots*yplots+1){#
						axis(1, cex.axis=0.8, at=c(0, 10, 20, 30, 40), labels=c(0, 10, 20, 30, 40))#
						}#
					if (k >= 2*xplots*yplots-xplots+1 & k < 2*xplots*yplots+1){#
						axis(1, cex.axis=0.8, at=c(0, 10, 20, 30, 40), labels=c(0, 10, 20, 30, 40))#
						}#
					if (k >= 3*xplots*yplots-xplots+1){#
						axis(1, cex.axis=0.8, at=c(0, 10, 20, 30, 40), labels=c(0, 10, 20, 30, 40))#
						}#
					}				#
#
				j <- 1#
				while (j <= numpages){#
					if (k %in% seq(1, j*yplots*xplots, by=xplots)) {axis(2, cex.axis=0.8, las=2)}#
					j <- j+1#
					}#
			}#
		}#
	}#
	else{#
		for (k in 1:length(data)){#
			plotRawMLCurve(data, ML, stand=standMax, i =k, dotedge=dotedge, maxDist=maxDist, ymax=ymax, label=label)#
		if(numpages == 1){#
				if (k >= xplots*yplots-xplots+1){#
					axis(1, cex.axis=0.8, at=c(0, 10, 20, 30, 40), labels=c(0, 10, 20, 30, 40))#
					}#
				}#
			if(numpages == 2){#
				if (k >= xplots*yplots-xplots+1 & k < xplots*yplots+1){#
					axis(1, cex.axis=0.8, at=c(0, 10, 20, 30, 40), labels=c(0, 10, 20, 30, 40))#
					}#
				if (k >= 2*xplots*yplots-xplots+1){#
					axis(1, cex.axis=0.8, at=c(0, 10, 20, 30, 40), labels=c(0, 10, 20, 30, 40))#
					}#
				}				#
			if(numpages == 3){#
				if (k >= xplots*yplots-xplots+1 & k < xplots*yplots+1){#
					axis(1, cex.axis=0.8, at=c(0, 10, 20, 30, 40), labels=c(0, 10, 20, 30, 40))#
					}#
				if (k >= 2*xplots*yplots-xplots+1 & k < 2*xplots*yplots+1){#
					axis(1, cex.axis=0.8, at=c(0, 10, 20, 30, 40), labels=c(0, 10, 20, 30, 40))#
					}#
				if (k >= 3*xplots*yplots-xplots+1){#
					axis(1, cex.axis=0.8, at=c(0, 10, 20, 30, 40), labels=c(0, 10, 20, 30, 40))#
					}#
				}				#
#
			j <- 1#
			while (j <= numpages){#
				if (k %in% seq(1, j*yplots*xplots, by=xplots)) {axis(2, cex.axis=0.8, las=2)}#
				j <- j+1#
				}#
		}#
	}	#
#
	mtext("Distance from edge of disc", outer=TRUE, side=1, line=2, cex=1.2)#
	mtext("Pixel density", outer=TRUE, side=2, line=1.5, cex=1.2)#
	dev.off()#
#
	if(popUp){#
		tt <- paste("open", t)#
		system(tt)#
	}#
	cat(paste("\n", projectName, ".ML has been written to the global environment", sep=""))#
	assign(paste(projectName, ".ML", sep=""), ML, envir=globalenv())#
}
maxLik("contrTest2", twoCurve=TRUE, maxDist=30)
plotMLCurve2Models <- function(data, i, MLparam,MLparam2, stand=standMax,  ymax=200, dotedge=3, maxDist= 40, label="", both=FALSE){ #
	startX <- which(data[[i]][,1] > dotedge+0.5)[1]#
	stopX <- which(data[[i]][,1] > maxDist - 0.5)[1]#
	data[[i]] <- data[[i]][startX:stopX, 1:2]#
	data[[i]] <- subset(data[[i]], x != "NA")#
	data[[i]]$x <- data[[i]]$x+ stand[i] -min(data[[i]]$x+stand[i])  #the micel only fits when it goes down to 0#
	data[[i]]$distance <- data[[i]]$distance - (dotedge+0.5)#
	xx <- seq(0, log(length(data[[i]][,1])), length=100) #
	yy2<- curve2(MLparam2[[i]]$par[1], MLparam2[[i]]$par[2], MLparam2[[i]]$par[3], MLparam2[[i]]$par[5], MLparam2[[i]]$par[6], MLparam2[[i]]$par[7],xx) + standEdge[i] #
	plot(data[[i]]$distance, data[[i]]$x, type="p", ylim=c(0, ymax), xaxt="n", yaxt="n", xlab="", ylab="", cex=0.8)#
	points(xx, yy2, type="l", col="red", lwd=2)#
	if (!both){#
		yy<- curve(MLparam[[i]]$par[1], MLparam[[i]]$par[2], MLparam[[i]]$par[3],xx)#
		points(xx, yy, type="l", col="green", lwd=2)#
	}#
    axis(2, las=2, at=c(0, ymax*0.25, ymax*0.5, ymax*0.75, ymax), labels=FALSE)#
    axis(1, labels=FALSE, at=c(0, 10, 20, 30, 40))#
	abline(v=exp(MLparam2[[i]]$par[2]))#
	abline(v=exp(MLparam2[[i]]$par[6]))#
	abline(h=MLparam2[[i]]$par[1] + MLparam2[[i]]$par[5] #
    mtext(label, side=3, cex=0.6)#
# 	mtext("Distance from edge of disc", outer=FALSE, side=1, line=2.5, cex=1.2)##
#	mtext("Pixel density", outer=FALSE, side=2, line=3, cex=1.2)#
	}
plotMLCurve2Models <- function(data, i, MLparam,MLparam2, stand=standMax,  ymax=200, dotedge=3, maxDist= 40, label="", both=FALSE){ #
	startX <- which(data[[i]][,1] > dotedge+0.5)[1]#
	stopX <- which(data[[i]][,1] > maxDist - 0.5)[1]#
	data[[i]] <- data[[i]][startX:stopX, 1:2]#
	data[[i]] <- subset(data[[i]], x != "NA")#
	data[[i]]$x <- data[[i]]$x+ stand[i] -min(data[[i]]$x+stand[i])  #the micel only fits when it goes down to 0#
	data[[i]]$distance <- data[[i]]$distance - (dotedge+0.5)#
	xx <- seq(0, log(length(data[[i]][,1])), length=100) #
	yy2<- curve2(MLparam2[[i]]$par[1], MLparam2[[i]]$par[2], MLparam2[[i]]$par[3], MLparam2[[i]]$par[5], MLparam2[[i]]$par[6], MLparam2[[i]]$par[7],xx) + standEdge[i] #
	plot(data[[i]]$distance, data[[i]]$x, type="p", ylim=c(0, ymax), xaxt="n", yaxt="n", xlab="", ylab="", cex=0.8)#
	points(xx, yy2, type="l", col="red", lwd=2)#
	if (!both){#
		yy<- curve(MLparam[[i]]$par[1], MLparam[[i]]$par[2], MLparam[[i]]$par[3],xx)#
		points(xx, yy, type="l", col="green", lwd=2)#
	}#
    axis(2, las=2, at=c(0, ymax*0.25, ymax*0.5, ymax*0.75, ymax), labels=FALSE)#
    axis(1, labels=FALSE, at=c(0, 10, 20, 30, 40))#
	abline(v=exp(MLparam2[[i]]$par[2]))#
	abline(v=exp(MLparam2[[i]]$par[6]))#
	abline(h=MLparam2[[i]]$par[1] + MLparam2[[i]]$par[5] )#
    mtext(label, side=3, cex=0.6)#
# 	mtext("Distance from edge of disc", outer=FALSE, side=1, line=2.5, cex=1.2)##
#	mtext("Pixel density", outer=FALSE, side=2, line=3, cex=1.2)#
	}
maxLik("contrTest2", twoCurve=TRUE, maxDist=30)
plotMLCurve2Models <- function(data, i, MLparam,MLparam2, stand=standMax,  ymax=200, dotedge=3, maxDist= 40, label="", both=FALSE){ #
	startX <- which(data[[i]][,1] > dotedge+0.5)[1]#
	stopX <- which(data[[i]][,1] > maxDist - 0.5)[1]#
	data[[i]] <- data[[i]][startX:stopX, 1:2]#
	data[[i]] <- subset(data[[i]], x != "NA")#
	data[[i]]$x <- data[[i]]$x+ stand[i] -min(data[[i]]$x+stand[i])  #the micel only fits when it goes down to 0#
	data[[i]]$distance <- data[[i]]$distance - (dotedge+0.5)#
	xx <- seq(0, log(length(data[[i]][,1])), length=100) #
	yy2<- curve2(MLparam2[[i]]$par[1], MLparam2[[i]]$par[2], MLparam2[[i]]$par[3], MLparam2[[i]]$par[5], MLparam2[[i]]$par[6], MLparam2[[i]]$par[7],xx) + stand[i]#
	plot(data[[i]]$distance, data[[i]]$x, type="p", ylim=c(0, ymax), xaxt="n", yaxt="n", xlab="", ylab="", cex=0.8)#
	points(xx, yy2, type="l", col="red", lwd=2)#
	if (!both){#
		yy<- curve(MLparam[[i]]$par[1], MLparam[[i]]$par[2], MLparam[[i]]$par[3],xx)#
		points(xx, yy, type="l", col="green", lwd=2)#
	}#
    axis(2, las=2, at=c(0, ymax*0.25, ymax*0.5, ymax*0.75, ymax), labels=FALSE)#
    axis(1, labels=FALSE, at=c(0, 10, 20, 30, 40))#
	abline(v=exp(MLparam2[[i]]$par[2]))#
	abline(v=exp(MLparam2[[i]]$par[6]))#
	abline(h=MLparam2[[i]]$par[1] + MLparam2[[i]]$par[5] )#
    mtext(label, side=3, cex=0.6)#
# 	mtext("Distance from edge of disc", outer=FALSE, side=1, line=2.5, cex=1.2)##
#	mtext("Pixel density", outer=FALSE, side=2, line=3, cex=1.2)#
	}
maxLik("contrTest2", twoCurve=TRUE, maxDist=30)
data <- contrTest2
label <- rep("", length(data))
dotMax <- max(sapply(data, function(x) {x[which(x[,1] > standardLoc)[1], 2]}))
standardLoc <- 0
dotedge <- 3
maxDist <- 30
ymax <- 200
xplots <- 6
maxSlope <- 20
dotMax <- max(sapply(data, function(x) {x[which(x[,1] > standardLoc)[1], 2]}))
standMax <-c( sapply(data, function(x) {dotMax-x[which(x[,1] > standardLoc)[1], 2]}))
ML <-lapply(c(1:length(data)), getstatsLog, data=data, dotedge=dotedge, maxDist=maxDist, stand=standMax, maxSlope=maxSlope)
ML2 <- lapply(c(1:length(data)), getstats2curve, data=data, dotedge=dotedge, maxDist=maxDist, stand=standMax, maxSlope=maxSlope)
compLik(ML, ML2)
t <- compLik(ML, ML2)
t
compLik <- function(ML1, ML2){	#
	numPar <- c()#
	diff <- c()#
#
	for (i in 1:length(ML1)){#
	diff[i] <- ML2[[i]]$lnLik	-ML1[[i]]$lnLik#
		if (((ML2[[i]]$lnLik - ML1[[i]]$lnLik)*2) > qchisq(0.95, 3)) {numPar[i] <- "2par"}#
		else {numPar[i] <- "1par"}	#
		}#
	return(list(diff, numPar))#
	}
t <- compLik(ML, ML2)
t
compLik <- function(ML1, ML2){	#
	numPar <- c()#
	diff <- c()#
#
	for (i in 1:length(ML1)){#
	diff[i] <- ML2[[i]]$lnLik	-ML1[[i]]$lnLik#
		if (((ML2[[i]]$lnLik - ML1[[i]]$lnLik)*2) > qchisq(0.95, 3)) {numPar[i] <- "2par"}#
		else {numPar[i] <- "1par"}	#
		}#
	return(data.frame(diff, numPar))#
	}
t <- compLik(ML, ML2)
t
xplots <- xplots
if (ceiling(length(data)/xplots) < 6) {#
		yplots<- ceiling(length(data)/xplots)}
yplots
numpages <- ceiling(length(data)/(xplots*yplots))
numpages
par(mfrow=c(yplots , xplots), mar=c(1,1,1,1), oma=c(4,5,1,1))
dev.off()
par(mfrow=c(yplots , xplots), mar=c(1,1,1,1), oma=c(4,5,1,1))
for (k in 1:length(data)){#
			plotMLCurve2Models(data, ML, ML2, stand=standMax, i =k, dotedge=dotedge, maxDist=maxDist, ymax=ymax, label=label[k])
if(numpages == 1){#
				if (k >= xplots*yplots-xplots+1){#
					axis(1, cex.axis=0.8, at=c(0, 10, 20, 30, 40), labels=c(0, 10, 20, 30, 40))#
					}#
				}
if(numpages == 2){#
				if (k >= xplots*yplots-xplots+1 & k < xplots*yplots+1){#
					axis(1, cex.axis=0.8, at=c(0, 10, 20, 30, 40), labels=c(0, 10, 20, 30, 40))#
					}#
				if (k >= 2*xplots*yplots-xplots+1){#
					axis(1, cex.axis=0.8, at=c(0, 10, 20, 30, 40), labels=c(0, 10, 20, 30, 40))#
					}#
				}				#
			if(numpages == 3){#
				if (k >= xplots*yplots-xplots+1 & k < xplots*yplots+1){#
					axis(1, cex.axis=0.8, at=c(0, 10, 20, 30, 40), labels=c(0, 10, 20, 30, 40))#
					}#
				if (k >= 2*xplots*yplots-xplots+1 & k < 2*xplots*yplots+1){#
					axis(1, cex.axis=0.8, at=c(0, 10, 20, 30, 40), labels=c(0, 10, 20, 30, 40))#
					}#
				if (k >= 3*xplots*yplots-xplots+1){#
					axis(1, cex.axis=0.8, at=c(0, 10, 20, 30, 40), labels=c(0, 10, 20, 30, 40))#
					}#
				}				#
#
			j <- 1#
			while (j <= numpages){#
				if (k %in% seq(1, j*yplots*xplots, by=xplots)) {axis(2, cex.axis=0.8, las=2)}#
				j <- j+1#
				}#
			}
plotMLCurve2Models <- function(data, i, MLparam,MLparam2, stand=standMax,  ymax=200, dotedge=3, maxDist= 40, label="", both=FALSE){ #
	startX <- which(data[[i]][,1] > dotedge+0.5)[1]#
	stopX <- which(data[[i]][,1] > maxDist - 0.5)[1]#
	data[[i]] <- data[[i]][startX:stopX, 1:2]#
	data[[i]] <- subset(data[[i]], x != "NA")#
	data[[i]]$x <- data[[i]]$x+ stand[i] -min(data[[i]]$x+stand[i])  #the micel only fits when it goes down to 0#
	data[[i]]$distance <- data[[i]]$distance - (dotedge+0.5)#
	xx <- seq(0, log(length(data[[i]][,1])), length=100) #
	yy2<- curve2(MLparam2[[i]]$par[1], MLparam2[[i]]$par[2], MLparam2[[i]]$par[3], MLparam2[[i]]$par[5], MLparam2[[i]]$par[6], MLparam2[[i]]$par[7],xx) + stand[i]#
	plot(data[[i]]$distance, data[[i]]$x, type="p", ylim=c(0, ymax), xaxt="n", yaxt="n", xlab="", ylab="", cex=0.8)#
	points(exp(xx), yy2, type="l", col="red", lwd=2)#
	if (!both){#
		yy<- curve(MLparam[[i]]$par[1], MLparam[[i]]$par[2], MLparam[[i]]$par[3],xx)#
		points(exp(xx), yy, type="l", col="green", lwd=2)#
	}#
    axis(2, las=2, at=c(0, ymax*0.25, ymax*0.5, ymax*0.75, ymax), labels=FALSE)#
    axis(1, labels=FALSE, at=c(0, 10, 20, 30, 40))#
	abline(v=exp(MLparam2[[i]]$par[2]))#
	abline(v=exp(MLparam2[[i]]$par[6]))#
	abline(h=MLparam2[[i]]$par[1] + MLparam2[[i]]$par[5] )#
    mtext(label, side=3, cex=0.6)#
# 	mtext("Distance from edge of disc", outer=FALSE, side=1, line=2.5, cex=1.2)##
#	mtext("Pixel density", outer=FALSE, side=2, line=3, cex=1.2)#
	}
if(numpages == 2){#
				if (k >= xplots*yplots-xplots+1 & k < xplots*yplots+1){#
					axis(1, cex.axis=0.8, at=c(0, 10, 20, 30, 40), labels=c(0, 10, 20, 30, 40))#
					}#
				if (k >= 2*xplots*yplots-xplots+1){#
					axis(1, cex.axis=0.8, at=c(0, 10, 20, 30, 40), labels=c(0, 10, 20, 30, 40))#
					}#
				}				#
			if(numpages == 3){#
				if (k >= xplots*yplots-xplots+1 & k < xplots*yplots+1){#
					axis(1, cex.axis=0.8, at=c(0, 10, 20, 30, 40), labels=c(0, 10, 20, 30, 40))#
					}#
				if (k >= 2*xplots*yplots-xplots+1 & k < 2*xplots*yplots+1){#
					axis(1, cex.axis=0.8, at=c(0, 10, 20, 30, 40), labels=c(0, 10, 20, 30, 40))#
					}#
				if (k >= 3*xplots*yplots-xplots+1){#
					axis(1, cex.axis=0.8, at=c(0, 10, 20, 30, 40), labels=c(0, 10, 20, 30, 40))#
					}#
				}				#
#
			j <- 1#
			while (j <= numpages){#
				if (k %in% seq(1, j*yplots*xplots, by=xplots)) {axis(2, cex.axis=0.8, las=2)}#
				j <- j+1#
				}#
			}
plotMLCurve2Models <- function(data, i, MLparam,MLparam2, stand=standMax,  ymax=200, dotedge=3, maxDist= 40, label="", both=FALSE){ #
	startX <- which(data[[i]][,1] > dotedge+0.5)[1]#
	stopX <- which(data[[i]][,1] > maxDist - 0.5)[1]#
	data[[i]] <- data[[i]][startX:stopX, 1:2]#
	data[[i]] <- subset(data[[i]], x != "NA")#
	data[[i]]$x <- data[[i]]$x+ stand[i] -min(data[[i]]$x+stand[i])  #the micel only fits when it goes down to 0#
	data[[i]]$distance <- data[[i]]$distance - (dotedge+0.5)#
	xx <- seq(0, log(length(data[[i]][,1])), length=100) #
	yy2<- curve2(MLparam2[[i]]$par[1], MLparam2[[i]]$par[2], MLparam2[[i]]$par[3], MLparam2[[i]]$par[5], MLparam2[[i]]$par[6], MLparam2[[i]]$par[7],xx) + stand[i]#
	plot(data[[i]]$distance, data[[i]]$x, type="p", ylim=c(0, ymax), xaxt="n", yaxt="n", xlab="", ylab="", cex=0.8)#
	points(exp(xx), yy2, type="l", col="red", lwd=2)#
	if (!both){#
		yy<- curve(MLparam[[i]]$par[1], MLparam[[i]]$par[2], MLparam[[i]]$par[3],xx)#
		points(exp(xx), yy, type="l", col="green", lwd=2)#
	}#
    axis(2, las=2, at=c(0, ymax*0.25, ymax*0.5, ymax*0.75, ymax), labels=FALSE)#
    axis(1, labels=FALSE, at=c(0, 10, 20, 30, 40))#
	abline(v=exp(MLparam2[[i]]$par[2]))#
	abline(v=exp(MLparam2[[i]]$par[6]))#
	abline(h=MLparam2[[i]]$par[1] + MLparam2[[i]]$par[5] )#
    mtext(label, side=3, cex=0.6)#
# 	mtext("Distance from edge of disc", outer=FALSE, side=1, line=2.5, cex=1.2)##
#	mtext("Pixel density", outer=FALSE, side=2, line=3, cex=1.2)#
	}
for (k in 1:length(data)){#
			plotMLCurve2Models(data, ML, ML2, stand=standMax, i =k, dotedge=dotedge, maxDist=maxDist, ymax=ymax, label=label[k])#
			if(numpages == 1){#
				if (k >= xplots*yplots-xplots+1){#
					axis(1, cex.axis=0.8, at=c(0, 10, 20, 30, 40), labels=c(0, 10, 20, 30, 40))#
					}#
				}#
			if(numpages == 2){#
				if (k >= xplots*yplots-xplots+1 & k < xplots*yplots+1){#
					axis(1, cex.axis=0.8, at=c(0, 10, 20, 30, 40), labels=c(0, 10, 20, 30, 40))#
					}#
				if (k >= 2*xplots*yplots-xplots+1){#
					axis(1, cex.axis=0.8, at=c(0, 10, 20, 30, 40), labels=c(0, 10, 20, 30, 40))#
					}#
				}				#
			if(numpages == 3){#
				if (k >= xplots*yplots-xplots+1 & k < xplots*yplots+1){#
					axis(1, cex.axis=0.8, at=c(0, 10, 20, 30, 40), labels=c(0, 10, 20, 30, 40))#
					}#
				if (k >= 2*xplots*yplots-xplots+1 & k < 2*xplots*yplots+1){#
					axis(1, cex.axis=0.8, at=c(0, 10, 20, 30, 40), labels=c(0, 10, 20, 30, 40))#
					}#
				if (k >= 3*xplots*yplots-xplots+1){#
					axis(1, cex.axis=0.8, at=c(0, 10, 20, 30, 40), labels=c(0, 10, 20, 30, 40))#
					}#
				}				#
#
			j <- 1#
			while (j <= numpages){#
				if (k %in% seq(1, j*yplots*xplots, by=xplots)) {axis(2, cex.axis=0.8, las=2)}#
				j <- j+1#
				}#
			}
par(mfrow=c(yplots , xplots), mar=c(1,1,1,1), oma=c(4,5,1,1))
for (k in 1:length(data)){#
			plotMLCurve2Models(data, ML, ML2, stand=standMax, i =k, dotedge=dotedge, maxDist=maxDist, ymax=ymax, label=label[k])#
			if(numpages == 1){#
				if (k >= xplots*yplots-xplots+1){#
					axis(1, cex.axis=0.8, at=c(0, 10, 20, 30, 40), labels=c(0, 10, 20, 30, 40))#
					}#
				}#
			if(numpages == 2){#
				if (k >= xplots*yplots-xplots+1 & k < xplots*yplots+1){#
					axis(1, cex.axis=0.8, at=c(0, 10, 20, 30, 40), labels=c(0, 10, 20, 30, 40))#
					}#
				if (k >= 2*xplots*yplots-xplots+1){#
					axis(1, cex.axis=0.8, at=c(0, 10, 20, 30, 40), labels=c(0, 10, 20, 30, 40))#
					}#
				}				#
			if(numpages == 3){#
				if (k >= xplots*yplots-xplots+1 & k < xplots*yplots+1){#
					axis(1, cex.axis=0.8, at=c(0, 10, 20, 30, 40), labels=c(0, 10, 20, 30, 40))#
					}#
				if (k >= 2*xplots*yplots-xplots+1 & k < 2*xplots*yplots+1){#
					axis(1, cex.axis=0.8, at=c(0, 10, 20, 30, 40), labels=c(0, 10, 20, 30, 40))#
					}#
				if (k >= 3*xplots*yplots-xplots+1){#
					axis(1, cex.axis=0.8, at=c(0, 10, 20, 30, 40), labels=c(0, 10, 20, 30, 40))#
					}#
				}				#
#
			j <- 1#
			while (j <= numpages){#
				if (k %in% seq(1, j*yplots*xplots, by=xplots)) {axis(2, cex.axis=0.8, las=2)}#
				j <- j+1#
				}#
			}
dotedge <- 3.25
ML <-lapply(c(1:length(data)), getstatsLog, data=data, dotedge=dotedge, maxDist=maxDist, stand=standMax, maxSlope=maxSlope)#
			ML2 <- lapply(c(1:length(data)), getstats2curve, data=data, dotedge=dotedge, maxDist=maxDist, stand=standMax, maxSlope=maxSlope)
test <- compLik(ML, ML2)
test
data <- contrTest2
ML <-lapply(c(1:length(data)), getstatsLog, data=data, dotedge=dotedge, maxDist=maxDist, stand=standMax, maxSlope=maxSlope)#
			ML2 <- lapply(c(1:length(data)), getstats2curve, data=data, dotedge=dotedge, maxDist=maxDist, stand=standMax, maxSlope=maxSlope)#
			test <- compLik(ML, ML2)
`	if(twoCurve){
}
sdfasdlkjfas
}}}{
dsfk;alsdjf;kladjsf;lkadjsf;lkasd
1
q
test
{}{}{}{}
"""""
"
}
6
^.
'
''''
"""
\\
source("/Users/acgerstein/Documents/Postdoc/Research/0CommonFiles/RScript/discAssay1_5f.R")
MAT5.t4 <- readInDir()
maxLik("MAT5.t4", dotedge=3.5, ymax=200, xplots=6, twoCurve=TRUE)
plotMLCurve2Models <- function(data, i, ML, ML2, stand=stand,  ymax=200, dotedge=3, maxDist= 35, percentileHigh = 0.8, label="", both=FALSE){ #
	startX <- which(data[[i]][,1] > dotedge+0.5)[1]#
	stopX <- which(data[[i]][,1] > maxDist - 0.5)[1]#
	data[[i]] <- data[[i]][startX:stopX, 1:2]#
	data[[i]]$x <- data[[i]]$x + stand[i] #
	data[[i]]$distance <- data[[i]]$distance - (dotedge+0.5)#
	xx <- seq(log(data[[i]]$distance[1]), log(max(data[[i]][,1])), length=200) #
	yy2<- curve2(ML2[[i]]$par[1], ML2[[i]]$par[2], ML2[[i]]$par[3], ML2[[i]]$par[5], ML2[[i]]$par[6], ML2[[i]]$par[7],xx) #
	plot(data[[i]]$distance, data[[i]]$x, type="p", ylim=c(0, ymax), xaxt="n", yaxt="n", xlab="", ylab="", cex=0.7, col=grey(0.4))#
#	points(exp(xx)- (dotedge+0.5), yy2, type="l", col="red", lwd=2)#
	slope <- max(ML2[[i]]$par[3], ML2[[i]]$par[7])#
	if(slope > 0.001){#
		points(exp(xx), yy2 + min(data[[i]]$x+stand[i]), type="l", col="red", lwd=2)	#
		abline(v=exp(ML2[[i]]$par[2]), col="red", lty=2)#
		abline(v=exp(ML2[[i]]$par[6]), col="red", lty=2)#
		abline(h=ML2[[i]]$par[1] + ML2[[i]]$par[5] +  min(data[[i]]$x+stand[i]), col="red", lty=2)#
#		abline(h=min(ML2[[i]]$par[1], ML2[[i]]$par[5]) +  min(data[[i]]$x+stand[i]), col="red", lty=2)#
		abline(v=exp(xx[which.max(yy2 > yy2[length(yy2)]*0.9)]), col="blue", lwd=2) #
	}#
	if (both){#
		yy<- curve(ML[[i]]$par[1], ML[[i]]$par[2], ML[[i]]$par[3],xx)#
		points(exp(xx), yy + min(data[[i]]$x+stand[i]), type="l", col="green", lwd=2)#
		abline(v=exp(ML[[i]]$par[2]), col="green", lty=2)#
		abline(h=ML[[i]]$par[1], col="green", lty=2)			#
	}#
    axis(2, las=2, at=c(0, ymax*0.25, ymax*0.5, ymax*0.75, ymax), labels=FALSE)#
    axis(1, labels=FALSE, at=c(0, 10, 20, 30, 40))#
    mtext(label, side=3, cex=0.6)#
#
# 	mtext("Distance from edge of disc", outer=FALSE, side=1, line=2.5, cex=1.2)##
#	mtext("Pixel density", outer=FALSE, side=2, line=3, cex=1.2)#
	}#
#exp(xx[which.max(yy2 > yy2[100]*0.9)])
maxLik("MAT5.t4", dotedge=3.5, ymax=200, xplots=6, twoCurve=TRUE)
MAT5.t4.ML2[[1]]
data <- MAT5.t4#
standardLoc <- 0
dotMax <- max(sapply(data, function(x) {x[which(x[,1] > standardLoc)[1], 2]})) 		#
stand <-c( sapply(data, function(x) {dotMax-x[which(x[,1] > standardLoc)[1], 2]}))
stand
range(stand)
range(stand)[2]
seq(0, 3, 100)
for (i in seq(0, 3, 0.1)
}
?append
standMax <- c()#
for (i in seq(0, 3, 0.1){#
	standardLox <- i#
	append(standMax, range(stand)[2])#
	}
standMax <- c()#
for (i in seq(0, 3, 0.1)){#
	standardLox <- i#
	append(standMax, range(stand)[2])#
	}
standMax
standMax <- c()#
for (i in seq(0, 3, 0.1)){#
	standardLox <- i#
	dotMax <- max(sapply(data, function(x) {x[which(x[,1] > standardLoc)[1], 2]})) 		#
	stand <-c( sapply(data, function(x) {dotMax-x[which(x[,1] > standardLoc)[1], 2]}))	#
	append(standMax, range(stand)[2])#
	}
standMax
seq(0, 3, 0.1))
seq(0, 3, 0.1)
standMax <- c()#
for (i in seq(0, 3, 0.1)){#
	standardLoc <- i#
	dotMax <- max(sapply(data, function(x) {x[which(x[,1] > standardLoc)[1], 2]})) 		#
	stand <-c( sapply(data, function(x) {dotMax-x[which(x[,1] > standardLoc)[1], 2]}))	#
	append(standMax, range(stand)[2])#
	}
standMax
i <- 0
dotMax <- max(sapply(data, function(x) {x[which(x[,1] > standardLoc)[1], 2]}))
stand <-c( sapply(data, function(x) {dotMax-x[which(x[,1] > standardLoc)[1], 2]}))
stand
range(stand)[2]
append(standMax, range(stand)[2])
standMax <- append(standMax, range(stand)[2])
standMax
standMax <- c()#
for (i in seq(0, 3, 0.1)){#
	standardLoc <- i#
	dotMax <- max(sapply(data, function(x) {x[which(x[,1] > standardLoc)[1], 2]})) 		#
	stand <-c( sapply(data, function(x) {dotMax-x[which(x[,1] > standardLoc)[1], 2]}))	#
	standMax <- append(standMax, range(stand)[2])#
	}
standMax
min(standMax)
standMax <- c()#
for (i in seq(0, 3, 0.01)){#
	standardLoc <- i#
	dotMax <- max(sapply(data, function(x) {x[which(x[,1] > standardLoc)[1], 2]})) 		#
	stand <-c( sapply(data, function(x) {dotMax-x[which(x[,1] > standardLoc)[1], 2]}))	#
	standMax <- append(standMax, range(stand)[2])#
	}
standMax
min(standMax)
plotRaw("MAT5.t4",  ymax = 275, xmax = 35, dotedge = 3.5)
plotRaw("MAT5.t4",  ymax = 275, xmax = 35, dotedge = 3)
plotRaw("MAT5.t4",  ymax = 325, xmax = 35, dotedge = 3)
plotRaw("MAT5.t4",  ymax = 325, xmax = 35, dotedge = 4)
plotRaw("MAT5.t4",  ymax = 325, xmax = 35, dotedge = 4, standardLoc = 4)
plotRaw("MAT5.t4",  ymax = 400, xmax = 35, dotedge = 4, standardLoc = 4)
maxLik("MAT5.t4", dotedge=4, ymax=200, xplots=6, twoCurve=TRUE, standardLoc = 4)
data <- MAT5.t4#
standardLoc <- 4#
dotMax <- max(sapply(data, function(x) {x[which(x[,1] > standardLoc)[1], 2]})) 		#
stand <-c( sapply(data, function(x) {dotMax-x[which(x[,1] > standardLoc)[1], 2]}))
plotMLCurve2Models(MAT5.t4, 1, MAT5.t4.ML, MAT5.t4.ML2, stand = stand, dotedge = 4)
devdev.capabilitiesdev.capabilitiesdev.capabilities
library(lme4)#
library(lmerTest)#
 cv <-function(x) sd(x,na.rm=TRUE)/mean(x,na.rm=TRUE)#
d <- read.csv("/Users/acgerstein/Documents/Postdoc/Research/TLO/Noise/Noise non-flow/microscopy/motherDaughter/Mother_Daughter_TLO_expression_final.csv", sep=",")#
d <- d[,1:3]#
d$LT <- paste(d$Line, d$Type, sep=".")#
ddn <- split(d, d$LT)#
numcells <- sapply(ddn, function(x) length(x[,1]))#
range(numcells)[1] #50 is the smallest#
#
ddnS <- lapply(ddn, function(x) sample(x$Expression, 50))#
Col <- sapply(as.character(names(ddn)), function(x) strsplit(x, "[.]")[[1]][1])#
Type <- sapply(as.character(names(ddn)), function(x) strsplit(x, "[.]")[[1]][2])#
#
dS <- data.frame(Line = rep(Col, each=50), Type = rep(Type, each=50), Expression=unlist(ddnS))#
dS$Expression[dS$Expression <= 0] <- 0.0001#
dS$Expression <- log(dS$Expression)
is.factor(ds$Type)
is.factor(dS$Type)
library(KernSmooth)
source("/Users/acgerstein/Documents/Postdoc/Research/0CommonFiles/RScript/discAssay2.R")
library(zoo)
F5DY<-readInExisting()
maxLik("F5DY", clearHalo = 28, maxDist = 30, xplots=4)
createDataframe("F5DY", clearHalo = 28)
source("/Users/acgerstein/Documents/Postdoc/Research/0CommonFiles/RScript/discAssay2.R")
createDataframe("F5DY", clearHalo = 28)
findAUC <- function(data, ML, ML2, stand, clearHaloStand, ZOIcor, dotedge = 3.4, maxDist = 35, ymax = 200, standardLoc = 2.5, percentileLow = 0.2,  i){	#
	startX <- which(data[[i]][,1] > dotedge+0.5)[1]#
	stopX <- which(data[[i]][,1] > maxDist - 0.5)[1]#
	data[[i]] <- data[[i]][startX:stopX, 1:2]#
	data[[i]]$x <- data[[i]]$x + stand[i] - clearHaloStand #
	data[[i]]$distance <- data[[i]]$distance - (dotedge+0.5)#
	xx <- seq(log(data[[i]]$distance[1]), log(max(data[[i]][,1])), length=200) #
	yy<- curve2(ML2[[i]]$par[1], ML2[[i]]$par[2], ML2[[i]]$par[3], ML2[[i]]$par[5], ML2[[i]]$par[6], ML2[[i]]$par[7], xx) #
	ic50 <- ML[[i]]$par[2]	#
	ploty <- data[[i]]$x#
	ploty[ploty < 0] <-0#
	yhalo <- (yy[which.max(yy> yy[length(yy)] * percentileLow)]+min(data[[i]]$x))#
	xhalo <- exp(xx[which.max(yy> yy[length(yy)] * 0.9)])		#
	x50 <- exp(xx[which.max(yy> yy[length(yy)] * 0.5)])			#
	minHalo <- exp(xx[which.max(yy> yy[length(yy)] * percentileLow)])		#
	ZOI <- xhalo		#
	slope <- ML[[i]]$par[3]#
	if(slope > 1){		#
			 xx <- seq(maxDist-1, maxDist, length=10)#
			yy<- curve2(ML2[[i]]$par[1], ML2[[i]]$par[2], ML2[[i]]$par[3], ML2[[i]]$par[5], ML2[[i]]$par[6], ML2[[i]]$par[7], log(xx)) #
			yy <- (yy+min(data[[i]]$x))#
			yy <- (yy+min(data[[i]]$x))*ZOIcor[i]#
			id <- order(xx)#
			maxAUC <- sum(diff(xx[id])*rollmean(yy[id], 2))	#
		xx <- seq(log(data[[i]]$distance[1]), log(max(data[[i]][,1])), length=200) 	#
		xx50 <- exp(xx[1:which.max(exp(xx) > x50)-1])		#
#		xx50 <- exp(xx[1:which.max(exp(xx) > exp(ic50))-1])		#
		xx90 <- exp(xx[1:which.max(exp(xx) > xhalo)-1])				#
#		xx <- exp(xx[1:which.max(exp(xx) > xhalo)-1])#
		if(length(xx50) == 0){#
			xx50 <- seq(log(data[[i]]$distance[1]), log(max(data[[i]][,1])), length=200) #
			}			#
		yy50<- curve2(ML2[[i]]$par[1], ML2[[i]]$par[2], ML2[[i]]$par[3], ML2[[i]]$par[5], ML2[[i]]$par[6], ML2[[i]]$par[7], log(xx50)) #
		yy90<- curve2(ML2[[i]]$par[1], ML2[[i]]$par[2], ML2[[i]]$par[3], ML2[[i]]$par[5], ML2[[i]]$par[6], ML2[[i]]$par[7], log(xx90)) #
#		yy <- (yy+min(data[[i]]$x))*ZOIcor[i]#
		yy50 <- (yy50+min(data[[i]]$x))#
		yy90 <- (yy90+min(data[[i]]$x))	#
		yy50[yy50  < 0] <-0#
		yy50[yy50 ==NaN] <- 0#
		yy90[yy90  < 0] <-0#
		yy90[yy90 ==NaN] <- 0#
		id50 <- order(xx50)#
		id90 <- order(xx90)#
		if (length(xx50) > 1){#
			AUC50 <- sum(diff(xx50[id50])*rollmean(yy50[id50], 2))		#
			}#
		else{#
			AUC50 <- 0#
			}#
		if (length(xx90) > 1){#
			AUC90 <- sum(diff(xx90[id90])*rollmean(yy90[id90], 2))		#
			}#
		else{#
			AUC90 <- 0#
			}#
		return(list(ZOI = ZOI, minHalo = minHalo, AUC50= AUC50, AUC90 = AUC90, maxAUC = maxAUC))	#
		}#
	if(slope < 1){#
		minHalo <- 0#
		ZOI <- 0#
		yy <- (yy+min(data[[i]]$x))*ZOIcor[i]#
		yy[yy < 0] <- 0#
		xx <- exp(xx)#
		id <- order(xx)#
		AUC <- sum(diff(xx[id])*rollmean(yy[id], 2))#
		maxAUC <- 1#
	}#
	return(list(ZOI = ZOI, minHalo = minHalo, AUC= AUC, maxAUC = maxAUC))		#
}
findAUC <- function(data, ML, ML2, stand, clearHaloStand, ZOIcor, dotedge = 3.4, maxDist = 35, ymax = 200, standardLoc = 2.5, percentileLow = 0.2,  i){	#
	startX <- which(data[[i]][,1] > dotedge+0.5)[1]#
	stopX <- which(data[[i]][,1] > maxDist - 0.5)[1]#
	data[[i]] <- data[[i]][startX:stopX, 1:2]#
	data[[i]]$x <- data[[i]]$x + stand[i] - clearHaloStand #
	data[[i]]$distance <- data[[i]]$distance - (dotedge+0.5)#
	xx <- seq(log(data[[i]]$distance[1]), log(max(data[[i]][,1])), length=200) #
	yy<- curve2(ML2[[i]]$par[1], ML2[[i]]$par[2], ML2[[i]]$par[3], ML2[[i]]$par[5], ML2[[i]]$par[6], ML2[[i]]$par[7], xx) #
	ic50 <- ML[[i]]$par[2]	#
	ploty <- data[[i]]$x#
	ploty[ploty < 0] <-0#
	yhalo <- (yy[which.max(yy> yy[length(yy)] * percentileLow)]+min(data[[i]]$x))#
	xhalo <- exp(xx[which.max(yy> yy[length(yy)] * 0.9)])	#
	x50 <- exp(xx[which.max(yy> yy[length(yy)] * 0.5)])						#
	minHalo <- exp(xx[which.max(yy> yy[length(yy)] * percentileLow)])		#
	ZOI <- xhalo	#
	slope <- ML[[i]]$par[3]#
	if(slope > 1){		#
			 xx <- seq(maxDist-1, maxDist, length=10)#
			yy<- curve2(ML2[[i]]$par[1], ML2[[i]]$par[2], ML2[[i]]$par[3], ML2[[i]]$par[5], ML2[[i]]$par[6], ML2[[i]]$par[7], log(xx)) #
			yy <- (yy+min(data[[i]]$x))#
			yy <- (yy+min(data[[i]]$x))*ZOIcor[i]#
			id <- order(xx)#
			maxAUC <- sum(diff(xx[id])*rollmean(yy[id], 2))	#
		xx <- seq(log(data[[i]]$distance[1]), log(max(data[[i]][,1])), length=200) 	#
		xx50 <- exp(xx[1:which.max(exp(xx) > x50)-1])		#
		xx90 <- exp(xx[1:which.max(exp(xx) > xhalo)-1])#
		if(length(xx50) == 0){#
			xx50 <- seq(log(data[[i]]$distance[1]), log(max(data[[i]][,1])), length=200) #
			}#
		yy50<- curve2(ML2[[i]]$par[1], ML2[[i]]$par[2], ML2[[i]]$par[3], ML2[[i]]$par[5], ML2[[i]]$par[6], ML2[[i]]$par[7], log(xx50)) #
		yy90<- curve2(ML2[[i]]$par[1], ML2[[i]]$par[2], ML2[[i]]$par[3], ML2[[i]]$par[5], ML2[[i]]$par[6], ML2[[i]]$par[7], log(xx90)) #
#
		yy50 <- (yy50+min(data[[i]]$x))#
		yy50[yy50  < 0] <-0#
		yy50[yy50 ==NaN] <- 0#
		id50 <- order(xx50)#
		if (length(xx50) > 1){#
			AUC50 <- sum(diff(xx50[id50])*rollmean(yy50[id50], 2))		#
			}#
		else{#
			AUC50 <- 0#
			}#
#
		yy90 <- (yy90+min(data[[i]]$x))#
		yy90[yy90  < 0] <-0#
		yy90[yy90 ==NaN] <- 0#
		id90 <- order(xx90)#
		if (length(xx90) > 1){#
			AUC90 <- sum(diff(xx90[id90])*rollmean(yy90[id90], 2))		#
			}#
		else{#
			AUC90 <- 0#
			}#
#
		return(list(ZOI = ZOI, minHalo = minHalo, AUC50= AUC90, AUC50= AUC90, maxAUC = maxAUC))	#
		}#
	if(slope < 1){#
		minHalo <- 0#
		ZOI <- 0#
		yy <- (yy+min(data[[i]]$x))*ZOIcor[i]#
		yy[yy < 0] <- 0#
		xx <- exp(xx)#
		id <- order(xx)#
		AUC <- sum(diff(xx[id])*rollmean(yy[id], 2))#
		AUC50 <- AUC  #Not sure this is what should be done, stopgap#
		AUC90 <- AUC  #Not sure this is what should be done, stopgap #
		maxAUC <- 1#
	}#
	return(list(ZOI = ZOI, minHalo = minHalo, AUC50= AUC50, AUC90 = AUC90, maxAUC = maxAUC))		#
}
d <- read.csv("/Users/acgerstein/Documents/Postdoc/Research/Clinical_isolates/Carl/excel/CarlOverviewMIC.csv", sep=",")#
ddn <- split(d, d$Strain)#
#
plotEE <- function(strain, name="", plotX = FALSE){#
	plot(ddn[[strain]]$Day, log(ddn[[strain]]$FLC.level), type="n", xaxt="n", yaxt="n", ylab="", xlab="", cex=1.5, ylim=c(log(0.5), log(300)))#
	axis(1, labels=FALSE)#
		for (i in ddn[[strain]]$Line){#
			sub <- subset(ddn[[strain]], Line ==i)#
			text(sub$Day[length(sub$Day)], log(sub$FLC.level)[length(sub$Day)], "X", col="red",  cex=1.5, font=2) #
			points(sub$Day, log(sub$FLC.level), type="b")#
			}#
	if(plotX) axis(1)#
	axis(2, las=2, labels=c("0.5", "2", "8", "32", "128"), at=c(log(0.5), log(2), log(8), log(32), log(128)))#
	mtext(name, side=3, adj=0.01, font=2)#
}#
#
FHT <- c(2, 10, 2, 7, 11, 10)#
SCT <- c(14, 5, 8, 14, 4, 9)#
T1 <- c(8, 5, 11, 9, 1, 14)
pdf("/Users/acgerstein/Documents/Postdoc/Research/Clinical_isolates/Carl/figures/transferResultsDemo.pdf", width=6, height=5)#
plotEE(1, "Strain A", plotX = TRUE)#
mtext("Day of transfer", side=1, line=2.5)#
mtext(expression(paste("Fluconazole concentration (", mu, "g/mL)", sep="")), side=2, line=2.5, outer=FALSE)#
dev.off()#
system("open /Users/acgerstein/Documents/Postdoc/Research/Clinical_isolates/Carl/figures/transferResultsDemo.pdf")
d <- read.csv("/Users/acgerstein/Documents/Postdoc/Research/Clinical_isolates/Carl/excel/CarlOverviewMIC.csv", sep=",")#
ddn <- split(d, d$Strain)#
#
plotEE <- function(strain, name="", plotX = FALSE){#
	plot(ddn[[strain]]$Day, log(ddn[[strain]]$FLC.level), type="n", xaxt="n", yaxt="n", ylab="", xlab="", cex=1.5, ylim=c(log(0.5), log(300)))#
	axis(1, labels=FALSE)#
		for (i in ddn[[strain]]$Line){#
			sub <- subset(ddn[[strain]], Line ==i)#
			text(sub$Day[length(sub$Day)], log(sub$FLC.level)[length(sub$Day)], "X", col="red",  cex=1.5, font=2) #
			points(sub$Day, log(sub$FLC.level), type="b")#
			}#
	if(plotX) axis(1)#
	axis(2, las=2, labels=c("0.5", "2", "8", "32", "128"), at=c(log(0.5), log(2), log(8), log(32), log(128)))#
	mtext(name, side=3, adj=0.01, font=2)#
}#
#
FHT <- c(2, 10, 2, 7, 11, 10)#
SCT <- c(14, 5, 8, 14, 4, 9)#
T1 <- c(8, 5, 11, 9, 1, 14)#
#
pdf("/Users/acgerstein/Documents/Postdoc/Research/Clinical_isolates/Carl/figures/transferResultsDemo.pdf", width=6, height=5)#
plotEE(1, "Strain A", plotX = TRUE)#
mtext("Day of transfer", side=1, line=2.5)#
mtext(expression(paste("Fluconazole concentration (", mu, "g/mL)", sep="")), side=2, line=2.5, outer=FALSE)#
dev.off()#
system("open /Users/acgerstein/Documents/Postdoc/Research/Clinical_isolates/Carl/figures/transferResultsDemo.pdf")
pdf("/Users/acgerstein/Documents/Postdoc/Research/Clinical_isolates/Carl/figures/transferResults.pdf", width=6, height=4.5)#
par(mfrow=c(3, 1), mar=c(1,1,2,1), oma=c(4, 4, 1, 1))#
plotEE(1, "Strain A")#
plotEE(2, "Strain B")#
plotEE(3,  "Strain C", plotX=TRUE)#
mtext("Day of transfer", side=1, line=2.5)#
mtext(expression(paste("Fluconazole concentration (", mu, "g/mL)", sep="")), side=2, line=1.5, outer=TRUE)#
dev.off()#
system("open /Users/acgerstein/Documents/Postdoc/Research/Clinical_isolates/Carl/figures/transferResults.pdf")
pdf("/Users/acgerstein/Documents/Postdoc/Research/Clinical_isolates/Carl/figures/MICResultsDemo.pdf", width=6, height=5)#
plotMIC(1, "Strain A", plotX = TRUE)#
abline(h=log(2), lty=2)#
mtext("MIC (fitness)", side=2, line=3, outer=FALSE)#
mtext(expression(paste("Fluconazole concentration in medium (", mu, "g/mL)", sep="")), side=1, line=3, outer=FALSE)#
dev.off()#
system("open /Users/acgerstein/Documents/Postdoc/Research/Clinical_isolates/Carl/figures/MICResultsDemo.pdf")
plotMIC <- function(strain, name, plotX = FALSE, plotY = TRUE){#
	plot(log(ddn[[strain]]$FLC.level), log(ddn[[strain]]$MIC1), type="n", xaxt="n", yaxt="n", ylab="", xlab="", cex=1.5, ylim=c(log(0.1), log(280)), xlim=c(log(0.5), log(160)))#
	axis(1, las=2, labels=FALSE, at=c(log(0.5), log(2), log(8), log(32), log(128)))#
		for (i in ddn[[strain]]$Line){#
			sub <- subset(ddn[[strain]], Line ==i)#
#			text(log(sub$FLC.level)[length(sub$MIC1)], log(sub$MIC1)[length(sub$MIC1)], "o", col="red",  cex=1.5, font=2) #
			points(log(sub$FLC.level), log(sub$MIC1), type="b")#
			}#
	if(plotY) axis(2, las=2, labels=c("0.125", "0.5", "2", "8", "32", "128", ">256"), at=c(log(0.125), log(0.5), log(2), log(8), log(32), log(128), log(275)))#
	if(plotX) axis(1, labels=c("0.5", "2", "8", "32", "128"), at=c(log(0.5), log(2), log(8), log(32), log(128)))#
	mtext(name, side=3, adj=0.01, font=2)	#
}#
#
sub2 <- sub <- subset(ddn[[1]], Line ==2)
pdf("/Users/acgerstein/Documents/Postdoc/Research/Clinical_isolates/Carl/figures/MICResultsDemo.pdf", width=6, height=5)#
plotMIC(1, "Strain A", plotX = TRUE)#
abline(h=log(2), lty=2)#
mtext("MIC (fitness)", side=2, line=3, outer=FALSE)#
mtext(expression(paste("Fluconazole concentration in medium (", mu, "g/mL)", sep="")), side=1, line=3, outer=FALSE)#
dev.off()#
system("open /Users/acgerstein/Documents/Postdoc/Research/Clinical_isolates/Carl/figures/MICResultsDemo.pdf")
pdf("/Users/acgerstein/Documents/Postdoc/Research/Clinical_isolates/Carl/figures/MICResultsFH-2.pdf", width=6, height=4)#
plot(log(sub2$FLC.level), log(sub2$MIC1), type="b", xaxt="n", yaxt="n", ylab="", xlab="", cex=1.5, ylim=c(log(0.25), log(280)), xlim=c(log(2), log(160)))#
axis(2, las=2, labels=c("0.125", "0.5", "2", "8", "32", "128", "256"), at=c(log(0.125), log(0.5), log(2), log(8), log(32), log(128), log(256)))#
axis(1, labels=c("0.5", "2", "8", "32", "128"), at=c(log(0.5), log(2), log(8), log(32), log(128)))#
mtext("MIC (fitness)", side=2, line=3, outer=FALSE)#
mtext(expression(paste("Fluconazole concentration in medium (", mu, "g/mL)", sep="")), side=1, line=3, outer=FALSE)#
dev.off()#
system("open /Users/acgerstein/Documents/Postdoc/Research/Clinical_isolates/Carl/figures/MICResultsFH-2.pdf")
pdf("/Users/acgerstein/Documents/Postdoc/Research/Clinical_isolates/Carl/figures/MICResultsDemo.pdf", width=6, height=5)#
plotMIC(1, "Strain A", plotX = TRUE)#
abline(h=log(2), lty=2)#
mtext("MIC (fitness)", side=2, line=3, outer=FALSE)#
mtext(expression(paste("Fluconazole concentration in medium (", mu, "g/mL)", sep="")), side=1, line=3, outer=FALSE)#
dev.off()#
system("open /Users/acgerstein/Documents/Postdoc/Research/Clinical_isolates/Carl/figures/MICResultsDemo.pdf")#
#
pdf("/Users/acgerstein/Documents/Postdoc/Research/Clinical_isolates/Carl/figures/MICResults.pdf", width=6, height=4.75)#
par(mfrow=c(3, 1), mar=c(1,1,1,1), oma=c(4, 4, 1, 1))#
plotMIC(1, "Strain A")#
abline(h=log(2), lty=2)#
plotMIC(2, "Strain B")#
points(c(log(16), log(64)), c(log(5), log(96)), type="l", lty=2)#
points(c(log(2), log(8)), c(log(0.19), log(0.16)), type="l", lty=2)#
abline(h=log(0.5), lty=2)#
plotMIC(3, "Strain C", plotX=TRUE)#
abline(h=log(0.5), lty=2)#
mtext("MIC (fitness)", side=2, line=2.5, outer=TRUE)#
mtext(expression(paste("Fluconazole concentration (", mu, "g/mL)", sep="")), side=1, line=2, outer=TRUE)#
dev.off()#
system("open /Users/acgerstein/Documents/Postdoc/Research/Clinical_isolates/Carl/figures/MICResults.pdf")
pdf("/Users/acgerstein/Documents/Postdoc/Research/Clinical_isolates/Carl/figures/MICResults.pdf", width=6, height=4.75)#
par(mfrow=c(3, 1), mar=c(1,1,1,1), oma=c(4, 4, 1, 1))#
plotMIC(1, "Strain A")#
abline(h=log(4), lty=2)#
plotMIC(2, "Strain B")#
points(c(log(16), log(64)), c(log(5), log(96)), type="l", lty=2)#
points(c(log(2), log(8)), c(log(0.19), log(0.16)), type="l", lty=2)#
abline(h=log(0.5), lty=2)#
plotMIC(3, "Strain C", plotX=TRUE)#
abline(h=log(0.5), lty=2)#
mtext("MIC (fitness)", side=2, line=2.5, outer=TRUE)#
mtext(expression(paste("Fluconazole concentration (", mu, "g/mL)", sep="")), side=1, line=2, outer=TRUE)#
dev.off()#
system("open /Users/acgerstein/Documents/Postdoc/Research/Clinical_isolates/Carl/figures/MICResults.pdf")
pdf("/Users/acgerstein/Documents/Postdoc/Research/Clinical_isolates/Carl/figures/MICResultsDemo.pdf", width=6, height=5)#
plotMIC(1, "Strain A", plotX = TRUE)#
abline(h=log(4), lty=2)#
mtext("MIC (fitness)", side=2, line=3, outer=FALSE)#
mtext(expression(paste("Fluconazole concentration in medium (", mu, "g/mL)", sep="")), side=1, line=3, outer=FALSE)#
dev.off()#
system("open /Users/acgerstein/Documents/Postdoc/Research/Clinical_isolates/Carl/figures/MICResultsDemo.pdf")
pdf("/Users/acgerstein/Documents/Postdoc/Research/Clinical_isolates/Carl/figures/MICResultsFH-2.pdf", width=6, height=4)#
plot(log(sub2$FLC.level), log(sub2$MIC1), type="b", xaxt="n", yaxt="n", ylab="", xlab="", cex=1.5, ylim=c(log(0.25), log(280)), xlim=c(log(4), log(160)))#
axis(2, las=2, labels=c("0.125", "0.5", "2", "8", "32", "128", "256"), at=c(log(0.125), log(0.5), log(2), log(8), log(32), log(128), log(256)))#
axis(1, labels=c("0.5", "2", "8", "32", "128"), at=c(log(0.5), log(2), log(8), log(32), log(128)))#
mtext("MIC (fitness)", side=2, line=3, outer=FALSE)#
mtext(expression(paste("Fluconazole concentration in medium (", mu, "g/mL)", sep="")), side=1, line=3, outer=FALSE)#
dev.off()#
system("open /Users/acgerstein/Documents/Postdoc/Research/Clinical_isolates/Carl/figures/MICResultsFH-2.pdf")
?diff
load("/Users/acgerstein/Documents/Postdoc/Things from:for others/UMN/Ben/test.RData")
.RData
library(devtools)#
install_github("acgerstein/diskImageR")#
library(markdown)#
library(knitr)#
setwd("Documents/Postdoc/Research/diskImageR/vignettes/")
#' Used to run the imageJ analysis by manually supplying path locations#
#
#' @description This function is used to run the imageJ analysis component of diskImageR by manually supplying the path location of the project directory (the directory where all subsequent analyses will be saved) and the location of the directory containing the photos to be analyzed.#
#
#' @param projectName the short name you want use for the project.#
#' @param projectDir the path to the project directory where all analyses will be saved#
#' @param pictureDir the path to the directory where the pictures are to be analyzed#
#' @param script the location of the imageJ script (AUTOMATE THIS)#
#' @param diskDiam the diameter of the diffusion disk in mm, defaults to 6.#
#' @param imageJLoc the absolute path to imageJ on your computer. Current options are standard for a mac: \code{imageJLoc} = "default" when imageJ is located at /Applications/ImageJ/ImageJ.app/Contents/MacOS/JavaApplicationStub; ly \code{imageJLoc} = "loc2" for path /Applications/ImageJ.app/Contents/MacOS/JavaApplicationStub#
#
#' @details Each photograph in the directory specified by \code{pictureDir} is input into ImageJ, where the built-in ‘find particles’ macro is used to find the center of a drug diffusion disk of the size specified by \code{diskDiam}. Lines are drawn every 5° out from the center of the disk, and the pixel intensity, which corresponds to cell density, is measured using the ‘plot-profile’ macro along each line. The results from all lines are saved into the "imageJ-out" directory in the specified \code{projectDir}. The average pixel intensity is then determined across all 72 lines at each distance and saved to \code{projectName}.#
#
#' @return A .csv file is saved to the directory "imageJ-out" in the directory specified by \code{projectDir}. The average line for each photograph is saved to the list \code{projectName} in the global environment.#
#
#' @export#
#
#' @seealso \code{\link{runIJ}} to run the imageJ analysis using the tcltk interface (i.e., pop-up boxes) to supply the project and picture directories. Test#
#
#'@author Aleeza C. Gerstein#
#
runIJManual <-#
function(projectName, projectDir, pictureDir, imageJLoc="default", discDiam = 6){#
	fileDir <- projectName#
	outputDir <- file.path(projectDir, "imageJ-out", fileDir, "")#
	script <- file.path(.libPaths(), "diskImageR", "IJ_diskImageR.txt")#
	IJarguments <- paste(pictureDir, outputDir, discDiam, sep="*")#
	if(length(dir(outputDir)) > 0){#
		stop("Output files already exist in specified directory. Please delete existing files or change project name before continuing.")#
	}#
	dir.create(file.path(projectDir, "imageJ-out"), showWarnings=FALSE)#
	dir.create(outputDir, showWarnings= FALSE)#
	dir.create(file.path(projectDir, "Figures"), showWarnings= FALSE)#
	if (imageJLoc=="default" | imageJLoc=="loc2" ){#
		if (imageJLoc=="loc2"){#
			call <- paste("/Applications/ImageJ/ImageJ.app/Contents/MacOS/JavaApplicationStub -batch", script, IJarguments, sep=" ")}#
		if (imageJLoc=="default"){#
			call <- paste("/Applications/ImageJ.app/Contents/MacOS/JavaApplicationStub -batch", script, IJarguments, sep=" ")}#
	}#
	else {call <- paste(imageJLoc,  "-batch", script, IJarguments, sep=" ")#
		}#
#
	system(call)#
#
	cat(paste("\nOutput of imageJ analyses saved in directory: ", fileDir, "\n", sep=""))#
	cat(paste("\nElements in dataframe ", projectName, ": \n", sep=""))	#
	temp <- .ReadIn_DirCreate(projectDir, outputDir, projectName)#
	cat("\a")#
	assign(projectName, temp, envir=globalenv())#
	}
runIJManual("vig", projectDir= getwd(), pictureDir = "../inst/pictures/, imageJLoc = "loc2")
runIJManual("vig", projectDir= getwd(), pictureDir = "../inst/pictures/", imageJLoc = "loc2")
library(diskImageR)
runIJManual("vig", projectDir= getwd(), pictureDir = "../inst/pictures/", imageJLoc = "loc2")
?runIJ
runIJManual("vig", projectDir= getwd(), pictureDir = "../inst/pictures/", imageJLoc = "loc2")
ls()
library("diskImageR")
ls()
runIJManual("vig", projectDir= getwd(), pictureDir = "../inst/pictures/", imageJLoc = "loc2")
library(devtools)
install_github("acgerstein/diskImageR")
library(devtools)#
install_github("acgerstein/diskImageR")
library("diskImageR")
runIJManual("vig", projectDir= getwd(), pictureDir = "../inst/pictures/", imageJLoc = "loc2")
library(devtools)#
install_github("acgerstein/diskImageR")
library("diskImageR")
runIJManual("vig", projectDir= getwd(), pictureDir = "../inst/pictures/", imageJLoc = "loc2")
getwd()
dir(.libPaths(), "diskImageR")
dir(.libPaths()/"diskImageR")
dir(".libPaths()/diskImageR")
setwd(.libPaths())
dir()
dir("diskImageR/")
runIJManual("vig", projectDir= getwd(), pictureDir = file.path(.libPaths(), "diskImageR", "pictures"), imageJLoc = "loc2")
runIJ("test")
runIJ("test", "loc2")
runIJManual <-#
function(projectName, projectDir, pictureDir, imageJLoc="default", discDiam = 6){#
	fileDir <- projectName#
	outputDir <- file.path(projectDir, "imageJ-out", fileDir, "")#
	script <- file.path(.libPaths(), "diskImageR", "IJ_diskImageR.txt")#
	IJarguments <- paste(pictureDir, outputDir, discDiam, sep="*")#
	if(length(dir(outputDir)) > 0){#
		stop("Output files already exist in specified directory. Please delete existing files or change project name before continuing.")#
	}#
	dir.create(file.path(projectDir, "imageJ-out"), showWarnings=FALSE)#
	dir.create(outputDir, showWarnings= FALSE)#
	dir.create(file.path(projectDir, "Figures"), showWarnings= FALSE)#
	if (imageJLoc=="default" | imageJLoc=="loc2" ){#
		if (imageJLoc=="loc2"){#
			call <- paste("~/Applications/ImageJ/ImageJ.app/Contents/MacOS/JavaApplicationStub -batch", script, IJarguments, sep=" ")}#
		if (imageJLoc=="default"){#
			call <- paste("~/Applications/ImageJ.app/Contents/MacOS/JavaApplicationStub -batch", script, IJarguments, sep=" ")}#
	}#
	else {call <- paste(imageJLoc,  "-batch", script, IJarguments, sep=" ")#
		}#
#
	system(call)#
#
	cat(paste("\nOutput of imageJ analyses saved in directory: ", fileDir, "\n", sep=""))#
	cat(paste("\nElements in dataframe ", projectName, ": \n", sep=""))	#
	temp <- .ReadIn_DirCreate(projectDir, outputDir, projectName)#
	cat("\a")#
	assign(projectName, temp, envir=globalenv())#
	}
runIJManual("vig", projectDir= getwd(), pictureDir = file.path(.libPaths(), "diskImageR", "pictures"), imageJLoc = "loc2")
runIJManual <-#
function(projectName, projectDir, pictureDir, imageJLoc="default", discDiam = 6){#
	fileDir <- projectName#
	outputDir <- file.path(projectDir, "imageJ-out", fileDir, "")#
	script <- file.path(.libPaths(), "diskImageR", "IJ_diskImageR.txt")#
	IJarguments <- paste(pictureDir, outputDir, discDiam, sep="*")#
	if(length(dir(outputDir)) > 0){#
		stop("Output files already exist in specified directory. Please delete existing files or change project name before continuing.")#
	}#
	dir.create(file.path(projectDir, "imageJ-out"), showWarnings=FALSE)#
	dir.create(outputDir, showWarnings= FALSE)#
	dir.create(file.path(projectDir, "Figures"), showWarnings= FALSE)#
	if (imageJLoc=="default" | imageJLoc=="loc2" ){#
		if (imageJLoc=="loc2"){#
			call <- paste("Applications/ImageJ/ImageJ.app/Contents/MacOS/JavaApplicationStub -batch", script, IJarguments, sep=" ")}#
		if (imageJLoc=="default"){#
			call <- paste("Applications/ImageJ.app/Contents/MacOS/JavaApplicationStub -batch", script, IJarguments, sep=" ")}#
	}#
	else {call <- paste(imageJLoc,  "-batch", script, IJarguments, sep=" ")#
		}#
#
	system(call)#
#
	cat(paste("\nOutput of imageJ analyses saved in directory: ", fileDir, "\n", sep=""))#
	cat(paste("\nElements in dataframe ", projectName, ": \n", sep=""))	#
	temp <- .ReadIn_DirCreate(projectDir, outputDir, projectName)#
	cat("\a")#
	assign(projectName, temp, envir=globalenv())#
	}
runIJManual("vig", projectDir= getwd(), pictureDir = file.path(.libPaths(), "diskImageR", "pictures"), imageJLoc = "loc2")
runIJManual <-#
function(projectName, projectDir, pictureDir, imageJLoc="default", discDiam = 6){#
	fileDir <- projectName#
	outputDir <- file.path(projectDir, "imageJ-out", fileDir, "")#
	script <- file.path(.libPaths(), "diskImageR", "IJ_diskImageR.txt")#
	IJarguments <- paste(pictureDir, outputDir, discDiam, sep="*")#
	if(length(dir(outputDir)) > 0){#
		stop("Output files already exist in specified directory. Please delete existing files or change project name before continuing.")#
	}#
	dir.create(file.path(projectDir, "imageJ-out"), showWarnings=FALSE)#
	dir.create(outputDir, showWarnings= FALSE)#
	dir.create(file.path(projectDir, "Figures"), showWarnings= FALSE)#
	if (imageJLoc=="default" | imageJLoc=="loc2" ){#
		if (imageJLoc=="loc2"){#
			call <- paste("/Applications/ImageJ/ImageJ.app/Contents/MacOS/JavaApplicationStub -batch", script, IJarguments, sep=" ")}#
		if (imageJLoc=="default"){#
			call <- paste("/Applications/ImageJ.app/Contents/MacOS/JavaApplicationStub -batch", script, IJarguments, sep=" ")}#
	}#
	else {call <- paste(imageJLoc,  "-batch", script, IJarguments, sep=" ")#
		}#
#
	system(call)#
#
	cat(paste("\nOutput of imageJ analyses saved in directory: ", fileDir, "\n", sep=""))#
	cat(paste("\nElements in dataframe ", projectName, ": \n", sep=""))	#
	temp <- .ReadIn_DirCreate(projectDir, outputDir, projectName)#
	cat("\a")#
	assign(projectName, temp, envir=globalenv())#
	}
runIJManual("vig", projectDir= getwd(), pictureDir = file.path(.libPaths(), "diskImageR", "pictures"), imageJLoc = "loc2")
runIJManual("vig", projectDir= "/Users/acgerstein/Documents/Postdoc/Research/", pictureDir = file.path(.libPaths(), "diskImageR", "pictures"), imageJLoc = "loc2")
runIJManual("vig", projectDir= "/Users/acgerstein/Documents/Postdoc/Research/", "/Users/acgerstein/Documents/Postdoc/Research/pictures", imageJLoc = "loc2")
#To manually input the locations of projectFolder, inputFolder and imageJ script#
runIJManual <- function(projectName, projectFolder, inputFolder, script, discDiam = 6, imageJLoc="default"){#
	fileFolder <- paste(Sys.Date(), projectName, sep="_")#
	outputFolder <- paste(projectFolder, "imageJ-out/", fileFolder, "/", sep="")#
	IJarguments <- paste(inputFolder, outputFolder, discDiam, sep="*")#
	if(length(dir(outputFolder)) > 0){#
		stop("Output files already exist in specified folder.  Please delete existing files or change project name before continuing.")#
	}#
	dir.create(paste(projectFolder, "/imageJ-out/", sep=""), showWarnings=FALSE)#
	dir.create(paste(outputFolder, sep=""), showWarnings= FALSE)#
	dir.create(paste(projectFolder, "/Figures/", sep=""), showWarnings= FALSE)#
	if (imageJLoc=="default" | imageJLoc=="loc2" ){#
		if (imageJLoc=="loc2"){#
			call <- paste("/Applications/ImageJ/ImageJ.app/Contents/MacOS/JavaApplicationStub -batch", script, IJarguments, sep=" ")}#
		if (imageJLoc=="default"){#
			call <- paste("/Applications/ImageJ.app/Contents/MacOS/JavaApplicationStub -batch", script, IJarguments, sep=" ")}#
	}#
	else {call <- paste(imageJLoc,  "-batch", script, IJarguments, sep=" ")#
		}#
#
	system(call)#
#
	fileFolder <- paste(Sys.Date(), projectName, sep="_")#
	cat(paste("\nOutput of imageJ analyses saved in folder: ", fileFolder, "\n", sep=""))#
	cat(paste("\nElements in dataframe ", projectName, ": \n", sep=""))	#
	temp <- ReadIn_DirCreate(projectFolder, outputFolder, projectName)#
	cat("\a")#
	assign(projectName, temp, envir=globalenv())#
	}
runIJManual("vig", projectDir= "/Users/acgerstein/Documents/Postdoc/Research/", "/Users/acgerstein/Documents/Postdoc/Research/pictures", imageJLoc = "loc2")
runIJManual("vig", projectDir= "/Users/acgerstein/Documents/Postdoc/Research/", "/Users/acgerstein/Documents/Postdoc/Research/pictures/", imageJLoc = "loc2")
runIJManual <-#
function(projectName, projectDir, pictureDir, imageJLoc="default", discDiam = 6){#
	fileDir <- projectName#
	outputDir <- file.path(projectDir, "imageJ-out", fileDir, "")#
	script <- file.path(.libPaths(), "diskImageR", "IJ_diskImageR.txt")#
	IJarguments <- paste(pictureDir, outputDir, discDiam, sep="*")#
	if(length(dir(outputDir)) > 0){#
		stop("Output files already exist in specified directory. Please delete existing files or change project name before continuing.")#
	}#
	dir.create(file.path(projectDir, "imageJ-out"), showWarnings=FALSE)#
	dir.create(outputDir, showWarnings= FALSE)#
	dir.create(file.path(projectDir, "Figures"), showWarnings= FALSE)#
	if (imageJLoc=="default" | imageJLoc=="loc2" ){#
		if (imageJLoc=="loc2"){#
			call <- paste("/Applications/ImageJ/ImageJ.app/Contents/MacOS/JavaApplicationStub -batch", script, IJarguments, sep=" ")}#
		if (imageJLoc=="default"){#
			call <- paste("/Applications/ImageJ.app/Contents/MacOS/JavaApplicationStub -batch", script, IJarguments, sep=" ")}#
	}#
	else {call <- paste(imageJLoc,  "-batch", script, IJarguments, sep=" ")#
		}#
#
	system(call)#
#
	cat(paste("\nOutput of imageJ analyses saved in directory: ", fileDir, "\n", sep=""))#
	cat(paste("\nElements in dataframe ", projectName, ": \n", sep=""))	#
	temp <- .ReadIn_DirCreate(projectDir, outputDir, projectName)#
	cat("\a")#
	assign(projectName, temp, envir=globalenv())#
	}
runIJManual("vig", projectDir= "/Users/acgerstein/Documents/Postdoc/Research/", "/Users/acgerstein/Documents/Postdoc/Research/pictures/", imageJLoc = "loc2")
install_github("acgerstein/diskImageR")#
library("diskImageR")
runIJManual("vig", projectDir= getwd(), pictureDir = file.path(.libPaths(), "diskImageR", "pictures", ""), imageJLoc = "loc2")
getwd()
setwd("diskImageR/vignettes/")
runIJManual("vig", projectDir= getwd(), pictureDir = file.path(.libPaths(), "diskImageR", "pictures", ""), imageJLoc = "loc2")
ls()
library(devtools)#
install_github("acgerstein/diskImageR")#
library("diskImageR")
runIJManual("vig", projectDir= getwd(), pictureDir = file.path(.libPaths(), "diskImageR", "pictures", ""), imageJLoc = "loc2")
runIJManual("vig", projectDir= getwd(), pictureDir = file.path(.libPaths(), "diskImageR", "pictures", ""), imageJLoc = "loc2")
.ReadIn_DirCreate <-#
function(workingDir, folderLoc, experAbbr){#
    setwd(workingDir)#
	tList <- list()#
	tList <- .readIn(folderLoc, tList, 30)#
	len <- c()#
		for (i in 1:length(tList)){#
		len[i] <- length(tList[[i]][,1])#
		}#
	temp <- data.frame(names = names(tList), len)#
	redo <- subset(temp, len==1, names)	#
	newdir1 <- file.path(workingDir, "figures", "")#
	newdir2 <- file.path(workingDir, "parameter_files", "")		#
	if (!file.exists(newdir1)){#
		dir.create(newdir1, showWarnings = FALSE)#
		cat(paste("new directory: ", newdir1), sep="")#
		}#
	if (!file.exists(newdir2)){		#
		dir.create(newdir2, showWarnings = FALSE)#
		cat(paste("new directory: ", newdir2), sep="")#
		}#
	tList#
	}
runIJManual("vig", projectDir= getwd(), pictureDir = file.path(.libPaths(), "diskImageR", "pictures", ""), imageJLoc = "loc2")
runIJManual("vig", projectDir= getwd(), pictureDir = file.path(.libPaths(), "diskImageR", "pictures", ""), imageJLoc = "loc2")
library(markdown)#
library(knitr)
setwd("Documents/Postdoc/Research/diskImageR/vignettes/")
knit2html("Quantitative Disk Assay.Rmd")
browseURL("Quantitative Disk Assay.html")
getwd()
knit2html("Quantitative Disk Assay.Rmd")
browseURL("Quantitative Disk Assay.html")
knit2html("Quantitative Disk Assay.Rmd")
browseURL("Quantitative Disk Assay.html")
browseURL("Quantitative Disk Assay.html")
knit2html("Quantitative Disk Assay.Rmd")
browseURL("Quantitative Disk Assay.html")
runIJManual <-#
function(projectName, projectDir, pictureDir, imageJLoc="default", discDiam = 6){#
	fileDir <- projectName#
	outputDir <- file.path(projectDir, "imageJ-out", fileDir, "")#
	script <- file.path(.libPaths(), "diskImageR", "IJ_diskImageR.txt")#
	IJarguments <- paste(pictureDir, outputDir, discDiam, sep="*")#
	if(length(dir(outputDir)) > 0){#
		stop("Output files already exist in specified directory. Please delete existing files or change project name before continuing.")#
	}#
	dir.create(file.path(projectDir, "imageJ-out"), showWarnings=FALSE)#
	dir.create(outputDir, showWarnings= FALSE)#
	dir.create(file.path(projectDir, "Figures"), showWarnings= FALSE)#
	if (imageJLoc=="default" | imageJLoc=="loc2" ){#
		if (imageJLoc=="loc2"){#
			call <- paste("/Applications/ImageJ/ImageJ.app/Contents/MacOS/JavaApplicationStub -batch", script, IJarguments, sep=" ")}#
		if (imageJLoc=="default"){#
			call <- paste("/Applications/ImageJ.app/Contents/MacOS/JavaApplicationStub -batch", script, IJarguments, sep=" ")}#
	}#
	else {call <- paste(imageJLoc,  "-batch", script, IJarguments, sep=" ")#
		}#
#
	system(call)#
#
	cat(paste("\nOutput of imageJ analyses saved in directory: ", outputDir, "\n", sep=""))#
	cat(paste("\nElements in dataframe ", projectName, ": \n", sep=""))	#
	temp <- .ReadIn_DirCreate(projectDir, outputDir, projectName)#
	cat("\a")#
	assign(projectName, temp, envir=globalenv())#
	}
knit2html("Quantitative Disk Assay.Rmd")
browseURL("Quantitative Disk Assay.html")
knit2html("Quantitative Disk Assay.Rmd")
browseURL("Quantitative Disk Assay.html")
library(devtools)#
install_github("acgerstein/diskImageR")#
library("diskImageR")#
library(markdown)#
library(knitr)
setwd("Documents/Postdoc/Research/diskImageR/vignettes/")
getwd()
knit2html("Quantitative Disk Assay.Rmd")
browseURL("Quantitative Disk Assay.html")
knit2html("Quantitative Disk Assay.Rmd")
browseURL("Quantitative Disk Assay.html")
knit2html("Quantitative Disk Assay.Rmd")
