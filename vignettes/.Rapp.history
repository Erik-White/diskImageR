par(mfrow=c(yplots , xplots), mar=c(1,1,1,1), oma=c(4,5,1,1))
dev.off()
par(mfrow=c(yplots , xplots), mar=c(1,1,1,1), oma=c(4,5,1,1))
for (k in 1:length(data)){#
			plotMLCurve2Models(data, ML, ML2, stand=standMax, i =k, dotedge=dotedge, maxDist=maxDist, ymax=ymax, label=label[k])
if(numpages == 1){#
				if (k >= xplots*yplots-xplots+1){#
					axis(1, cex.axis=0.8, at=c(0, 10, 20, 30, 40), labels=c(0, 10, 20, 30, 40))#
					}#
				}
if(numpages == 2){#
				if (k >= xplots*yplots-xplots+1 & k < xplots*yplots+1){#
					axis(1, cex.axis=0.8, at=c(0, 10, 20, 30, 40), labels=c(0, 10, 20, 30, 40))#
					}#
				if (k >= 2*xplots*yplots-xplots+1){#
					axis(1, cex.axis=0.8, at=c(0, 10, 20, 30, 40), labels=c(0, 10, 20, 30, 40))#
					}#
				}				#
			if(numpages == 3){#
				if (k >= xplots*yplots-xplots+1 & k < xplots*yplots+1){#
					axis(1, cex.axis=0.8, at=c(0, 10, 20, 30, 40), labels=c(0, 10, 20, 30, 40))#
					}#
				if (k >= 2*xplots*yplots-xplots+1 & k < 2*xplots*yplots+1){#
					axis(1, cex.axis=0.8, at=c(0, 10, 20, 30, 40), labels=c(0, 10, 20, 30, 40))#
					}#
				if (k >= 3*xplots*yplots-xplots+1){#
					axis(1, cex.axis=0.8, at=c(0, 10, 20, 30, 40), labels=c(0, 10, 20, 30, 40))#
					}#
				}				#
#
			j <- 1#
			while (j <= numpages){#
				if (k %in% seq(1, j*yplots*xplots, by=xplots)) {axis(2, cex.axis=0.8, las=2)}#
				j <- j+1#
				}#
			}
plotMLCurve2Models <- function(data, i, MLparam,MLparam2, stand=standMax,  ymax=200, dotedge=3, maxDist= 40, label="", both=FALSE){ #
	startX <- which(data[[i]][,1] > dotedge+0.5)[1]#
	stopX <- which(data[[i]][,1] > maxDist - 0.5)[1]#
	data[[i]] <- data[[i]][startX:stopX, 1:2]#
	data[[i]] <- subset(data[[i]], x != "NA")#
	data[[i]]$x <- data[[i]]$x+ stand[i] -min(data[[i]]$x+stand[i])  #the micel only fits when it goes down to 0#
	data[[i]]$distance <- data[[i]]$distance - (dotedge+0.5)#
	xx <- seq(0, log(length(data[[i]][,1])), length=100) #
	yy2<- curve2(MLparam2[[i]]$par[1], MLparam2[[i]]$par[2], MLparam2[[i]]$par[3], MLparam2[[i]]$par[5], MLparam2[[i]]$par[6], MLparam2[[i]]$par[7],xx) + stand[i]#
	plot(data[[i]]$distance, data[[i]]$x, type="p", ylim=c(0, ymax), xaxt="n", yaxt="n", xlab="", ylab="", cex=0.8)#
	points(exp(xx), yy2, type="l", col="red", lwd=2)#
	if (!both){#
		yy<- curve(MLparam[[i]]$par[1], MLparam[[i]]$par[2], MLparam[[i]]$par[3],xx)#
		points(exp(xx), yy, type="l", col="green", lwd=2)#
	}#
    axis(2, las=2, at=c(0, ymax*0.25, ymax*0.5, ymax*0.75, ymax), labels=FALSE)#
    axis(1, labels=FALSE, at=c(0, 10, 20, 30, 40))#
	abline(v=exp(MLparam2[[i]]$par[2]))#
	abline(v=exp(MLparam2[[i]]$par[6]))#
	abline(h=MLparam2[[i]]$par[1] + MLparam2[[i]]$par[5] )#
    mtext(label, side=3, cex=0.6)#
# 	mtext("Distance from edge of disc", outer=FALSE, side=1, line=2.5, cex=1.2)##
#	mtext("Pixel density", outer=FALSE, side=2, line=3, cex=1.2)#
	}
if(numpages == 2){#
				if (k >= xplots*yplots-xplots+1 & k < xplots*yplots+1){#
					axis(1, cex.axis=0.8, at=c(0, 10, 20, 30, 40), labels=c(0, 10, 20, 30, 40))#
					}#
				if (k >= 2*xplots*yplots-xplots+1){#
					axis(1, cex.axis=0.8, at=c(0, 10, 20, 30, 40), labels=c(0, 10, 20, 30, 40))#
					}#
				}				#
			if(numpages == 3){#
				if (k >= xplots*yplots-xplots+1 & k < xplots*yplots+1){#
					axis(1, cex.axis=0.8, at=c(0, 10, 20, 30, 40), labels=c(0, 10, 20, 30, 40))#
					}#
				if (k >= 2*xplots*yplots-xplots+1 & k < 2*xplots*yplots+1){#
					axis(1, cex.axis=0.8, at=c(0, 10, 20, 30, 40), labels=c(0, 10, 20, 30, 40))#
					}#
				if (k >= 3*xplots*yplots-xplots+1){#
					axis(1, cex.axis=0.8, at=c(0, 10, 20, 30, 40), labels=c(0, 10, 20, 30, 40))#
					}#
				}				#
#
			j <- 1#
			while (j <= numpages){#
				if (k %in% seq(1, j*yplots*xplots, by=xplots)) {axis(2, cex.axis=0.8, las=2)}#
				j <- j+1#
				}#
			}
plotMLCurve2Models <- function(data, i, MLparam,MLparam2, stand=standMax,  ymax=200, dotedge=3, maxDist= 40, label="", both=FALSE){ #
	startX <- which(data[[i]][,1] > dotedge+0.5)[1]#
	stopX <- which(data[[i]][,1] > maxDist - 0.5)[1]#
	data[[i]] <- data[[i]][startX:stopX, 1:2]#
	data[[i]] <- subset(data[[i]], x != "NA")#
	data[[i]]$x <- data[[i]]$x+ stand[i] -min(data[[i]]$x+stand[i])  #the micel only fits when it goes down to 0#
	data[[i]]$distance <- data[[i]]$distance - (dotedge+0.5)#
	xx <- seq(0, log(length(data[[i]][,1])), length=100) #
	yy2<- curve2(MLparam2[[i]]$par[1], MLparam2[[i]]$par[2], MLparam2[[i]]$par[3], MLparam2[[i]]$par[5], MLparam2[[i]]$par[6], MLparam2[[i]]$par[7],xx) + stand[i]#
	plot(data[[i]]$distance, data[[i]]$x, type="p", ylim=c(0, ymax), xaxt="n", yaxt="n", xlab="", ylab="", cex=0.8)#
	points(exp(xx), yy2, type="l", col="red", lwd=2)#
	if (!both){#
		yy<- curve(MLparam[[i]]$par[1], MLparam[[i]]$par[2], MLparam[[i]]$par[3],xx)#
		points(exp(xx), yy, type="l", col="green", lwd=2)#
	}#
    axis(2, las=2, at=c(0, ymax*0.25, ymax*0.5, ymax*0.75, ymax), labels=FALSE)#
    axis(1, labels=FALSE, at=c(0, 10, 20, 30, 40))#
	abline(v=exp(MLparam2[[i]]$par[2]))#
	abline(v=exp(MLparam2[[i]]$par[6]))#
	abline(h=MLparam2[[i]]$par[1] + MLparam2[[i]]$par[5] )#
    mtext(label, side=3, cex=0.6)#
# 	mtext("Distance from edge of disc", outer=FALSE, side=1, line=2.5, cex=1.2)##
#	mtext("Pixel density", outer=FALSE, side=2, line=3, cex=1.2)#
	}
for (k in 1:length(data)){#
			plotMLCurve2Models(data, ML, ML2, stand=standMax, i =k, dotedge=dotedge, maxDist=maxDist, ymax=ymax, label=label[k])#
			if(numpages == 1){#
				if (k >= xplots*yplots-xplots+1){#
					axis(1, cex.axis=0.8, at=c(0, 10, 20, 30, 40), labels=c(0, 10, 20, 30, 40))#
					}#
				}#
			if(numpages == 2){#
				if (k >= xplots*yplots-xplots+1 & k < xplots*yplots+1){#
					axis(1, cex.axis=0.8, at=c(0, 10, 20, 30, 40), labels=c(0, 10, 20, 30, 40))#
					}#
				if (k >= 2*xplots*yplots-xplots+1){#
					axis(1, cex.axis=0.8, at=c(0, 10, 20, 30, 40), labels=c(0, 10, 20, 30, 40))#
					}#
				}				#
			if(numpages == 3){#
				if (k >= xplots*yplots-xplots+1 & k < xplots*yplots+1){#
					axis(1, cex.axis=0.8, at=c(0, 10, 20, 30, 40), labels=c(0, 10, 20, 30, 40))#
					}#
				if (k >= 2*xplots*yplots-xplots+1 & k < 2*xplots*yplots+1){#
					axis(1, cex.axis=0.8, at=c(0, 10, 20, 30, 40), labels=c(0, 10, 20, 30, 40))#
					}#
				if (k >= 3*xplots*yplots-xplots+1){#
					axis(1, cex.axis=0.8, at=c(0, 10, 20, 30, 40), labels=c(0, 10, 20, 30, 40))#
					}#
				}				#
#
			j <- 1#
			while (j <= numpages){#
				if (k %in% seq(1, j*yplots*xplots, by=xplots)) {axis(2, cex.axis=0.8, las=2)}#
				j <- j+1#
				}#
			}
par(mfrow=c(yplots , xplots), mar=c(1,1,1,1), oma=c(4,5,1,1))
for (k in 1:length(data)){#
			plotMLCurve2Models(data, ML, ML2, stand=standMax, i =k, dotedge=dotedge, maxDist=maxDist, ymax=ymax, label=label[k])#
			if(numpages == 1){#
				if (k >= xplots*yplots-xplots+1){#
					axis(1, cex.axis=0.8, at=c(0, 10, 20, 30, 40), labels=c(0, 10, 20, 30, 40))#
					}#
				}#
			if(numpages == 2){#
				if (k >= xplots*yplots-xplots+1 & k < xplots*yplots+1){#
					axis(1, cex.axis=0.8, at=c(0, 10, 20, 30, 40), labels=c(0, 10, 20, 30, 40))#
					}#
				if (k >= 2*xplots*yplots-xplots+1){#
					axis(1, cex.axis=0.8, at=c(0, 10, 20, 30, 40), labels=c(0, 10, 20, 30, 40))#
					}#
				}				#
			if(numpages == 3){#
				if (k >= xplots*yplots-xplots+1 & k < xplots*yplots+1){#
					axis(1, cex.axis=0.8, at=c(0, 10, 20, 30, 40), labels=c(0, 10, 20, 30, 40))#
					}#
				if (k >= 2*xplots*yplots-xplots+1 & k < 2*xplots*yplots+1){#
					axis(1, cex.axis=0.8, at=c(0, 10, 20, 30, 40), labels=c(0, 10, 20, 30, 40))#
					}#
				if (k >= 3*xplots*yplots-xplots+1){#
					axis(1, cex.axis=0.8, at=c(0, 10, 20, 30, 40), labels=c(0, 10, 20, 30, 40))#
					}#
				}				#
#
			j <- 1#
			while (j <= numpages){#
				if (k %in% seq(1, j*yplots*xplots, by=xplots)) {axis(2, cex.axis=0.8, las=2)}#
				j <- j+1#
				}#
			}
dotedge <- 3.25
ML <-lapply(c(1:length(data)), getstatsLog, data=data, dotedge=dotedge, maxDist=maxDist, stand=standMax, maxSlope=maxSlope)#
			ML2 <- lapply(c(1:length(data)), getstats2curve, data=data, dotedge=dotedge, maxDist=maxDist, stand=standMax, maxSlope=maxSlope)
test <- compLik(ML, ML2)
test
data <- contrTest2
ML <-lapply(c(1:length(data)), getstatsLog, data=data, dotedge=dotedge, maxDist=maxDist, stand=standMax, maxSlope=maxSlope)#
			ML2 <- lapply(c(1:length(data)), getstats2curve, data=data, dotedge=dotedge, maxDist=maxDist, stand=standMax, maxSlope=maxSlope)#
			test <- compLik(ML, ML2)
`	if(twoCurve){
}
sdfasdlkjfas
}}}{
dsfk;alsdjf;kladjsf;lkadjsf;lkasd
1
q
test
{}{}{}{}
"""""
"
}
6
^.
'
''''
"""
\\
source("/Users/acgerstein/Documents/Postdoc/Research/0CommonFiles/RScript/discAssay1_5f.R")
MAT5.t4 <- readInDir()
maxLik("MAT5.t4", dotedge=3.5, ymax=200, xplots=6, twoCurve=TRUE)
plotMLCurve2Models <- function(data, i, ML, ML2, stand=stand,  ymax=200, dotedge=3, maxDist= 35, percentileHigh = 0.8, label="", both=FALSE){ #
	startX <- which(data[[i]][,1] > dotedge+0.5)[1]#
	stopX <- which(data[[i]][,1] > maxDist - 0.5)[1]#
	data[[i]] <- data[[i]][startX:stopX, 1:2]#
	data[[i]]$x <- data[[i]]$x + stand[i] #
	data[[i]]$distance <- data[[i]]$distance - (dotedge+0.5)#
	xx <- seq(log(data[[i]]$distance[1]), log(max(data[[i]][,1])), length=200) #
	yy2<- curve2(ML2[[i]]$par[1], ML2[[i]]$par[2], ML2[[i]]$par[3], ML2[[i]]$par[5], ML2[[i]]$par[6], ML2[[i]]$par[7],xx) #
	plot(data[[i]]$distance, data[[i]]$x, type="p", ylim=c(0, ymax), xaxt="n", yaxt="n", xlab="", ylab="", cex=0.7, col=grey(0.4))#
#	points(exp(xx)- (dotedge+0.5), yy2, type="l", col="red", lwd=2)#
	slope <- max(ML2[[i]]$par[3], ML2[[i]]$par[7])#
	if(slope > 0.001){#
		points(exp(xx), yy2 + min(data[[i]]$x+stand[i]), type="l", col="red", lwd=2)	#
		abline(v=exp(ML2[[i]]$par[2]), col="red", lty=2)#
		abline(v=exp(ML2[[i]]$par[6]), col="red", lty=2)#
		abline(h=ML2[[i]]$par[1] + ML2[[i]]$par[5] +  min(data[[i]]$x+stand[i]), col="red", lty=2)#
#		abline(h=min(ML2[[i]]$par[1], ML2[[i]]$par[5]) +  min(data[[i]]$x+stand[i]), col="red", lty=2)#
		abline(v=exp(xx[which.max(yy2 > yy2[length(yy2)]*0.9)]), col="blue", lwd=2) #
	}#
	if (both){#
		yy<- curve(ML[[i]]$par[1], ML[[i]]$par[2], ML[[i]]$par[3],xx)#
		points(exp(xx), yy + min(data[[i]]$x+stand[i]), type="l", col="green", lwd=2)#
		abline(v=exp(ML[[i]]$par[2]), col="green", lty=2)#
		abline(h=ML[[i]]$par[1], col="green", lty=2)			#
	}#
    axis(2, las=2, at=c(0, ymax*0.25, ymax*0.5, ymax*0.75, ymax), labels=FALSE)#
    axis(1, labels=FALSE, at=c(0, 10, 20, 30, 40))#
    mtext(label, side=3, cex=0.6)#
#
# 	mtext("Distance from edge of disc", outer=FALSE, side=1, line=2.5, cex=1.2)##
#	mtext("Pixel density", outer=FALSE, side=2, line=3, cex=1.2)#
	}#
#exp(xx[which.max(yy2 > yy2[100]*0.9)])
maxLik("MAT5.t4", dotedge=3.5, ymax=200, xplots=6, twoCurve=TRUE)
MAT5.t4.ML2[[1]]
data <- MAT5.t4#
standardLoc <- 0
dotMax <- max(sapply(data, function(x) {x[which(x[,1] > standardLoc)[1], 2]})) 		#
stand <-c( sapply(data, function(x) {dotMax-x[which(x[,1] > standardLoc)[1], 2]}))
stand
range(stand)
range(stand)[2]
seq(0, 3, 100)
for (i in seq(0, 3, 0.1)
}
?append
standMax <- c()#
for (i in seq(0, 3, 0.1){#
	standardLox <- i#
	append(standMax, range(stand)[2])#
	}
standMax <- c()#
for (i in seq(0, 3, 0.1)){#
	standardLox <- i#
	append(standMax, range(stand)[2])#
	}
standMax
standMax <- c()#
for (i in seq(0, 3, 0.1)){#
	standardLox <- i#
	dotMax <- max(sapply(data, function(x) {x[which(x[,1] > standardLoc)[1], 2]})) 		#
	stand <-c( sapply(data, function(x) {dotMax-x[which(x[,1] > standardLoc)[1], 2]}))	#
	append(standMax, range(stand)[2])#
	}
standMax
seq(0, 3, 0.1))
seq(0, 3, 0.1)
standMax <- c()#
for (i in seq(0, 3, 0.1)){#
	standardLoc <- i#
	dotMax <- max(sapply(data, function(x) {x[which(x[,1] > standardLoc)[1], 2]})) 		#
	stand <-c( sapply(data, function(x) {dotMax-x[which(x[,1] > standardLoc)[1], 2]}))	#
	append(standMax, range(stand)[2])#
	}
standMax
i <- 0
dotMax <- max(sapply(data, function(x) {x[which(x[,1] > standardLoc)[1], 2]}))
stand <-c( sapply(data, function(x) {dotMax-x[which(x[,1] > standardLoc)[1], 2]}))
stand
range(stand)[2]
append(standMax, range(stand)[2])
standMax <- append(standMax, range(stand)[2])
standMax
standMax <- c()#
for (i in seq(0, 3, 0.1)){#
	standardLoc <- i#
	dotMax <- max(sapply(data, function(x) {x[which(x[,1] > standardLoc)[1], 2]})) 		#
	stand <-c( sapply(data, function(x) {dotMax-x[which(x[,1] > standardLoc)[1], 2]}))	#
	standMax <- append(standMax, range(stand)[2])#
	}
standMax
min(standMax)
standMax <- c()#
for (i in seq(0, 3, 0.01)){#
	standardLoc <- i#
	dotMax <- max(sapply(data, function(x) {x[which(x[,1] > standardLoc)[1], 2]})) 		#
	stand <-c( sapply(data, function(x) {dotMax-x[which(x[,1] > standardLoc)[1], 2]}))	#
	standMax <- append(standMax, range(stand)[2])#
	}
standMax
min(standMax)
plotRaw("MAT5.t4",  ymax = 275, xmax = 35, dotedge = 3.5)
plotRaw("MAT5.t4",  ymax = 275, xmax = 35, dotedge = 3)
plotRaw("MAT5.t4",  ymax = 325, xmax = 35, dotedge = 3)
plotRaw("MAT5.t4",  ymax = 325, xmax = 35, dotedge = 4)
plotRaw("MAT5.t4",  ymax = 325, xmax = 35, dotedge = 4, standardLoc = 4)
plotRaw("MAT5.t4",  ymax = 400, xmax = 35, dotedge = 4, standardLoc = 4)
maxLik("MAT5.t4", dotedge=4, ymax=200, xplots=6, twoCurve=TRUE, standardLoc = 4)
data <- MAT5.t4#
standardLoc <- 4#
dotMax <- max(sapply(data, function(x) {x[which(x[,1] > standardLoc)[1], 2]})) 		#
stand <-c( sapply(data, function(x) {dotMax-x[which(x[,1] > standardLoc)[1], 2]}))
plotMLCurve2Models(MAT5.t4, 1, MAT5.t4.ML, MAT5.t4.ML2, stand = stand, dotedge = 4)
devdev.capabilitiesdev.capabilitiesdev.capabilities
library(lme4)#
library(lmerTest)#
 cv <-function(x) sd(x,na.rm=TRUE)/mean(x,na.rm=TRUE)#
d <- read.csv("/Users/acgerstein/Documents/Postdoc/Research/TLO/Noise/Noise non-flow/microscopy/motherDaughter/Mother_Daughter_TLO_expression_final.csv", sep=",")#
d <- d[,1:3]#
d$LT <- paste(d$Line, d$Type, sep=".")#
ddn <- split(d, d$LT)#
numcells <- sapply(ddn, function(x) length(x[,1]))#
range(numcells)[1] #50 is the smallest#
#
ddnS <- lapply(ddn, function(x) sample(x$Expression, 50))#
Col <- sapply(as.character(names(ddn)), function(x) strsplit(x, "[.]")[[1]][1])#
Type <- sapply(as.character(names(ddn)), function(x) strsplit(x, "[.]")[[1]][2])#
#
dS <- data.frame(Line = rep(Col, each=50), Type = rep(Type, each=50), Expression=unlist(ddnS))#
dS$Expression[dS$Expression <= 0] <- 0.0001#
dS$Expression <- log(dS$Expression)
is.factor(ds$Type)
is.factor(dS$Type)
library(KernSmooth)
source("/Users/acgerstein/Documents/Postdoc/Research/0CommonFiles/RScript/discAssay2.R")
library(zoo)
F5DY<-readInExisting()
maxLik("F5DY", clearHalo = 28, maxDist = 30, xplots=4)
createDataframe("F5DY", clearHalo = 28)
source("/Users/acgerstein/Documents/Postdoc/Research/0CommonFiles/RScript/discAssay2.R")
createDataframe("F5DY", clearHalo = 28)
findAUC <- function(data, ML, ML2, stand, clearHaloStand, ZOIcor, dotedge = 3.4, maxDist = 35, ymax = 200, standardLoc = 2.5, percentileLow = 0.2,  i){	#
	startX <- which(data[[i]][,1] > dotedge+0.5)[1]#
	stopX <- which(data[[i]][,1] > maxDist - 0.5)[1]#
	data[[i]] <- data[[i]][startX:stopX, 1:2]#
	data[[i]]$x <- data[[i]]$x + stand[i] - clearHaloStand #
	data[[i]]$distance <- data[[i]]$distance - (dotedge+0.5)#
	xx <- seq(log(data[[i]]$distance[1]), log(max(data[[i]][,1])), length=200) #
	yy<- curve2(ML2[[i]]$par[1], ML2[[i]]$par[2], ML2[[i]]$par[3], ML2[[i]]$par[5], ML2[[i]]$par[6], ML2[[i]]$par[7], xx) #
	ic50 <- ML[[i]]$par[2]	#
	ploty <- data[[i]]$x#
	ploty[ploty < 0] <-0#
	yhalo <- (yy[which.max(yy> yy[length(yy)] * percentileLow)]+min(data[[i]]$x))#
	xhalo <- exp(xx[which.max(yy> yy[length(yy)] * 0.9)])		#
	x50 <- exp(xx[which.max(yy> yy[length(yy)] * 0.5)])			#
	minHalo <- exp(xx[which.max(yy> yy[length(yy)] * percentileLow)])		#
	ZOI <- xhalo		#
	slope <- ML[[i]]$par[3]#
	if(slope > 1){		#
			 xx <- seq(maxDist-1, maxDist, length=10)#
			yy<- curve2(ML2[[i]]$par[1], ML2[[i]]$par[2], ML2[[i]]$par[3], ML2[[i]]$par[5], ML2[[i]]$par[6], ML2[[i]]$par[7], log(xx)) #
			yy <- (yy+min(data[[i]]$x))#
			yy <- (yy+min(data[[i]]$x))*ZOIcor[i]#
			id <- order(xx)#
			maxAUC <- sum(diff(xx[id])*rollmean(yy[id], 2))	#
		xx <- seq(log(data[[i]]$distance[1]), log(max(data[[i]][,1])), length=200) 	#
		xx50 <- exp(xx[1:which.max(exp(xx) > x50)-1])		#
#		xx50 <- exp(xx[1:which.max(exp(xx) > exp(ic50))-1])		#
		xx90 <- exp(xx[1:which.max(exp(xx) > xhalo)-1])				#
#		xx <- exp(xx[1:which.max(exp(xx) > xhalo)-1])#
		if(length(xx50) == 0){#
			xx50 <- seq(log(data[[i]]$distance[1]), log(max(data[[i]][,1])), length=200) #
			}			#
		yy50<- curve2(ML2[[i]]$par[1], ML2[[i]]$par[2], ML2[[i]]$par[3], ML2[[i]]$par[5], ML2[[i]]$par[6], ML2[[i]]$par[7], log(xx50)) #
		yy90<- curve2(ML2[[i]]$par[1], ML2[[i]]$par[2], ML2[[i]]$par[3], ML2[[i]]$par[5], ML2[[i]]$par[6], ML2[[i]]$par[7], log(xx90)) #
#		yy <- (yy+min(data[[i]]$x))*ZOIcor[i]#
		yy50 <- (yy50+min(data[[i]]$x))#
		yy90 <- (yy90+min(data[[i]]$x))	#
		yy50[yy50  < 0] <-0#
		yy50[yy50 ==NaN] <- 0#
		yy90[yy90  < 0] <-0#
		yy90[yy90 ==NaN] <- 0#
		id50 <- order(xx50)#
		id90 <- order(xx90)#
		if (length(xx50) > 1){#
			AUC50 <- sum(diff(xx50[id50])*rollmean(yy50[id50], 2))		#
			}#
		else{#
			AUC50 <- 0#
			}#
		if (length(xx90) > 1){#
			AUC90 <- sum(diff(xx90[id90])*rollmean(yy90[id90], 2))		#
			}#
		else{#
			AUC90 <- 0#
			}#
		return(list(ZOI = ZOI, minHalo = minHalo, AUC50= AUC50, AUC90 = AUC90, maxAUC = maxAUC))	#
		}#
	if(slope < 1){#
		minHalo <- 0#
		ZOI <- 0#
		yy <- (yy+min(data[[i]]$x))*ZOIcor[i]#
		yy[yy < 0] <- 0#
		xx <- exp(xx)#
		id <- order(xx)#
		AUC <- sum(diff(xx[id])*rollmean(yy[id], 2))#
		maxAUC <- 1#
	}#
	return(list(ZOI = ZOI, minHalo = minHalo, AUC= AUC, maxAUC = maxAUC))		#
}
findAUC <- function(data, ML, ML2, stand, clearHaloStand, ZOIcor, dotedge = 3.4, maxDist = 35, ymax = 200, standardLoc = 2.5, percentileLow = 0.2,  i){	#
	startX <- which(data[[i]][,1] > dotedge+0.5)[1]#
	stopX <- which(data[[i]][,1] > maxDist - 0.5)[1]#
	data[[i]] <- data[[i]][startX:stopX, 1:2]#
	data[[i]]$x <- data[[i]]$x + stand[i] - clearHaloStand #
	data[[i]]$distance <- data[[i]]$distance - (dotedge+0.5)#
	xx <- seq(log(data[[i]]$distance[1]), log(max(data[[i]][,1])), length=200) #
	yy<- curve2(ML2[[i]]$par[1], ML2[[i]]$par[2], ML2[[i]]$par[3], ML2[[i]]$par[5], ML2[[i]]$par[6], ML2[[i]]$par[7], xx) #
	ic50 <- ML[[i]]$par[2]	#
	ploty <- data[[i]]$x#
	ploty[ploty < 0] <-0#
	yhalo <- (yy[which.max(yy> yy[length(yy)] * percentileLow)]+min(data[[i]]$x))#
	xhalo <- exp(xx[which.max(yy> yy[length(yy)] * 0.9)])	#
	x50 <- exp(xx[which.max(yy> yy[length(yy)] * 0.5)])						#
	minHalo <- exp(xx[which.max(yy> yy[length(yy)] * percentileLow)])		#
	ZOI <- xhalo	#
	slope <- ML[[i]]$par[3]#
	if(slope > 1){		#
			 xx <- seq(maxDist-1, maxDist, length=10)#
			yy<- curve2(ML2[[i]]$par[1], ML2[[i]]$par[2], ML2[[i]]$par[3], ML2[[i]]$par[5], ML2[[i]]$par[6], ML2[[i]]$par[7], log(xx)) #
			yy <- (yy+min(data[[i]]$x))#
			yy <- (yy+min(data[[i]]$x))*ZOIcor[i]#
			id <- order(xx)#
			maxAUC <- sum(diff(xx[id])*rollmean(yy[id], 2))	#
		xx <- seq(log(data[[i]]$distance[1]), log(max(data[[i]][,1])), length=200) 	#
		xx50 <- exp(xx[1:which.max(exp(xx) > x50)-1])		#
		xx90 <- exp(xx[1:which.max(exp(xx) > xhalo)-1])#
		if(length(xx50) == 0){#
			xx50 <- seq(log(data[[i]]$distance[1]), log(max(data[[i]][,1])), length=200) #
			}#
		yy50<- curve2(ML2[[i]]$par[1], ML2[[i]]$par[2], ML2[[i]]$par[3], ML2[[i]]$par[5], ML2[[i]]$par[6], ML2[[i]]$par[7], log(xx50)) #
		yy90<- curve2(ML2[[i]]$par[1], ML2[[i]]$par[2], ML2[[i]]$par[3], ML2[[i]]$par[5], ML2[[i]]$par[6], ML2[[i]]$par[7], log(xx90)) #
#
		yy50 <- (yy50+min(data[[i]]$x))#
		yy50[yy50  < 0] <-0#
		yy50[yy50 ==NaN] <- 0#
		id50 <- order(xx50)#
		if (length(xx50) > 1){#
			AUC50 <- sum(diff(xx50[id50])*rollmean(yy50[id50], 2))		#
			}#
		else{#
			AUC50 <- 0#
			}#
#
		yy90 <- (yy90+min(data[[i]]$x))#
		yy90[yy90  < 0] <-0#
		yy90[yy90 ==NaN] <- 0#
		id90 <- order(xx90)#
		if (length(xx90) > 1){#
			AUC90 <- sum(diff(xx90[id90])*rollmean(yy90[id90], 2))		#
			}#
		else{#
			AUC90 <- 0#
			}#
#
		return(list(ZOI = ZOI, minHalo = minHalo, AUC50= AUC90, AUC50= AUC90, maxAUC = maxAUC))	#
		}#
	if(slope < 1){#
		minHalo <- 0#
		ZOI <- 0#
		yy <- (yy+min(data[[i]]$x))*ZOIcor[i]#
		yy[yy < 0] <- 0#
		xx <- exp(xx)#
		id <- order(xx)#
		AUC <- sum(diff(xx[id])*rollmean(yy[id], 2))#
		AUC50 <- AUC  #Not sure this is what should be done, stopgap#
		AUC90 <- AUC  #Not sure this is what should be done, stopgap #
		maxAUC <- 1#
	}#
	return(list(ZOI = ZOI, minHalo = minHalo, AUC50= AUC50, AUC90 = AUC90, maxAUC = maxAUC))		#
}
d <- read.csv("/Users/acgerstein/Documents/Postdoc/Research/Clinical_isolates/Carl/excel/CarlOverviewMIC.csv", sep=",")#
ddn <- split(d, d$Strain)#
#
plotEE <- function(strain, name="", plotX = FALSE){#
	plot(ddn[[strain]]$Day, log(ddn[[strain]]$FLC.level), type="n", xaxt="n", yaxt="n", ylab="", xlab="", cex=1.5, ylim=c(log(0.5), log(300)))#
	axis(1, labels=FALSE)#
		for (i in ddn[[strain]]$Line){#
			sub <- subset(ddn[[strain]], Line ==i)#
			text(sub$Day[length(sub$Day)], log(sub$FLC.level)[length(sub$Day)], "X", col="red",  cex=1.5, font=2) #
			points(sub$Day, log(sub$FLC.level), type="b")#
			}#
	if(plotX) axis(1)#
	axis(2, las=2, labels=c("0.5", "2", "8", "32", "128"), at=c(log(0.5), log(2), log(8), log(32), log(128)))#
	mtext(name, side=3, adj=0.01, font=2)#
}#
#
FHT <- c(2, 10, 2, 7, 11, 10)#
SCT <- c(14, 5, 8, 14, 4, 9)#
T1 <- c(8, 5, 11, 9, 1, 14)
pdf("/Users/acgerstein/Documents/Postdoc/Research/Clinical_isolates/Carl/figures/transferResultsDemo.pdf", width=6, height=5)#
plotEE(1, "Strain A", plotX = TRUE)#
mtext("Day of transfer", side=1, line=2.5)#
mtext(expression(paste("Fluconazole concentration (", mu, "g/mL)", sep="")), side=2, line=2.5, outer=FALSE)#
dev.off()#
system("open /Users/acgerstein/Documents/Postdoc/Research/Clinical_isolates/Carl/figures/transferResultsDemo.pdf")
d <- read.csv("/Users/acgerstein/Documents/Postdoc/Research/Clinical_isolates/Carl/excel/CarlOverviewMIC.csv", sep=",")#
ddn <- split(d, d$Strain)#
#
plotEE <- function(strain, name="", plotX = FALSE){#
	plot(ddn[[strain]]$Day, log(ddn[[strain]]$FLC.level), type="n", xaxt="n", yaxt="n", ylab="", xlab="", cex=1.5, ylim=c(log(0.5), log(300)))#
	axis(1, labels=FALSE)#
		for (i in ddn[[strain]]$Line){#
			sub <- subset(ddn[[strain]], Line ==i)#
			text(sub$Day[length(sub$Day)], log(sub$FLC.level)[length(sub$Day)], "X", col="red",  cex=1.5, font=2) #
			points(sub$Day, log(sub$FLC.level), type="b")#
			}#
	if(plotX) axis(1)#
	axis(2, las=2, labels=c("0.5", "2", "8", "32", "128"), at=c(log(0.5), log(2), log(8), log(32), log(128)))#
	mtext(name, side=3, adj=0.01, font=2)#
}#
#
FHT <- c(2, 10, 2, 7, 11, 10)#
SCT <- c(14, 5, 8, 14, 4, 9)#
T1 <- c(8, 5, 11, 9, 1, 14)#
#
pdf("/Users/acgerstein/Documents/Postdoc/Research/Clinical_isolates/Carl/figures/transferResultsDemo.pdf", width=6, height=5)#
plotEE(1, "Strain A", plotX = TRUE)#
mtext("Day of transfer", side=1, line=2.5)#
mtext(expression(paste("Fluconazole concentration (", mu, "g/mL)", sep="")), side=2, line=2.5, outer=FALSE)#
dev.off()#
system("open /Users/acgerstein/Documents/Postdoc/Research/Clinical_isolates/Carl/figures/transferResultsDemo.pdf")
pdf("/Users/acgerstein/Documents/Postdoc/Research/Clinical_isolates/Carl/figures/transferResults.pdf", width=6, height=4.5)#
par(mfrow=c(3, 1), mar=c(1,1,2,1), oma=c(4, 4, 1, 1))#
plotEE(1, "Strain A")#
plotEE(2, "Strain B")#
plotEE(3,  "Strain C", plotX=TRUE)#
mtext("Day of transfer", side=1, line=2.5)#
mtext(expression(paste("Fluconazole concentration (", mu, "g/mL)", sep="")), side=2, line=1.5, outer=TRUE)#
dev.off()#
system("open /Users/acgerstein/Documents/Postdoc/Research/Clinical_isolates/Carl/figures/transferResults.pdf")
pdf("/Users/acgerstein/Documents/Postdoc/Research/Clinical_isolates/Carl/figures/MICResultsDemo.pdf", width=6, height=5)#
plotMIC(1, "Strain A", plotX = TRUE)#
abline(h=log(2), lty=2)#
mtext("MIC (fitness)", side=2, line=3, outer=FALSE)#
mtext(expression(paste("Fluconazole concentration in medium (", mu, "g/mL)", sep="")), side=1, line=3, outer=FALSE)#
dev.off()#
system("open /Users/acgerstein/Documents/Postdoc/Research/Clinical_isolates/Carl/figures/MICResultsDemo.pdf")
plotMIC <- function(strain, name, plotX = FALSE, plotY = TRUE){#
	plot(log(ddn[[strain]]$FLC.level), log(ddn[[strain]]$MIC1), type="n", xaxt="n", yaxt="n", ylab="", xlab="", cex=1.5, ylim=c(log(0.1), log(280)), xlim=c(log(0.5), log(160)))#
	axis(1, las=2, labels=FALSE, at=c(log(0.5), log(2), log(8), log(32), log(128)))#
		for (i in ddn[[strain]]$Line){#
			sub <- subset(ddn[[strain]], Line ==i)#
#			text(log(sub$FLC.level)[length(sub$MIC1)], log(sub$MIC1)[length(sub$MIC1)], "o", col="red",  cex=1.5, font=2) #
			points(log(sub$FLC.level), log(sub$MIC1), type="b")#
			}#
	if(plotY) axis(2, las=2, labels=c("0.125", "0.5", "2", "8", "32", "128", ">256"), at=c(log(0.125), log(0.5), log(2), log(8), log(32), log(128), log(275)))#
	if(plotX) axis(1, labels=c("0.5", "2", "8", "32", "128"), at=c(log(0.5), log(2), log(8), log(32), log(128)))#
	mtext(name, side=3, adj=0.01, font=2)	#
}#
#
sub2 <- sub <- subset(ddn[[1]], Line ==2)
pdf("/Users/acgerstein/Documents/Postdoc/Research/Clinical_isolates/Carl/figures/MICResultsDemo.pdf", width=6, height=5)#
plotMIC(1, "Strain A", plotX = TRUE)#
abline(h=log(2), lty=2)#
mtext("MIC (fitness)", side=2, line=3, outer=FALSE)#
mtext(expression(paste("Fluconazole concentration in medium (", mu, "g/mL)", sep="")), side=1, line=3, outer=FALSE)#
dev.off()#
system("open /Users/acgerstein/Documents/Postdoc/Research/Clinical_isolates/Carl/figures/MICResultsDemo.pdf")
pdf("/Users/acgerstein/Documents/Postdoc/Research/Clinical_isolates/Carl/figures/MICResultsFH-2.pdf", width=6, height=4)#
plot(log(sub2$FLC.level), log(sub2$MIC1), type="b", xaxt="n", yaxt="n", ylab="", xlab="", cex=1.5, ylim=c(log(0.25), log(280)), xlim=c(log(2), log(160)))#
axis(2, las=2, labels=c("0.125", "0.5", "2", "8", "32", "128", "256"), at=c(log(0.125), log(0.5), log(2), log(8), log(32), log(128), log(256)))#
axis(1, labels=c("0.5", "2", "8", "32", "128"), at=c(log(0.5), log(2), log(8), log(32), log(128)))#
mtext("MIC (fitness)", side=2, line=3, outer=FALSE)#
mtext(expression(paste("Fluconazole concentration in medium (", mu, "g/mL)", sep="")), side=1, line=3, outer=FALSE)#
dev.off()#
system("open /Users/acgerstein/Documents/Postdoc/Research/Clinical_isolates/Carl/figures/MICResultsFH-2.pdf")
pdf("/Users/acgerstein/Documents/Postdoc/Research/Clinical_isolates/Carl/figures/MICResultsDemo.pdf", width=6, height=5)#
plotMIC(1, "Strain A", plotX = TRUE)#
abline(h=log(2), lty=2)#
mtext("MIC (fitness)", side=2, line=3, outer=FALSE)#
mtext(expression(paste("Fluconazole concentration in medium (", mu, "g/mL)", sep="")), side=1, line=3, outer=FALSE)#
dev.off()#
system("open /Users/acgerstein/Documents/Postdoc/Research/Clinical_isolates/Carl/figures/MICResultsDemo.pdf")#
#
pdf("/Users/acgerstein/Documents/Postdoc/Research/Clinical_isolates/Carl/figures/MICResults.pdf", width=6, height=4.75)#
par(mfrow=c(3, 1), mar=c(1,1,1,1), oma=c(4, 4, 1, 1))#
plotMIC(1, "Strain A")#
abline(h=log(2), lty=2)#
plotMIC(2, "Strain B")#
points(c(log(16), log(64)), c(log(5), log(96)), type="l", lty=2)#
points(c(log(2), log(8)), c(log(0.19), log(0.16)), type="l", lty=2)#
abline(h=log(0.5), lty=2)#
plotMIC(3, "Strain C", plotX=TRUE)#
abline(h=log(0.5), lty=2)#
mtext("MIC (fitness)", side=2, line=2.5, outer=TRUE)#
mtext(expression(paste("Fluconazole concentration (", mu, "g/mL)", sep="")), side=1, line=2, outer=TRUE)#
dev.off()#
system("open /Users/acgerstein/Documents/Postdoc/Research/Clinical_isolates/Carl/figures/MICResults.pdf")
pdf("/Users/acgerstein/Documents/Postdoc/Research/Clinical_isolates/Carl/figures/MICResults.pdf", width=6, height=4.75)#
par(mfrow=c(3, 1), mar=c(1,1,1,1), oma=c(4, 4, 1, 1))#
plotMIC(1, "Strain A")#
abline(h=log(4), lty=2)#
plotMIC(2, "Strain B")#
points(c(log(16), log(64)), c(log(5), log(96)), type="l", lty=2)#
points(c(log(2), log(8)), c(log(0.19), log(0.16)), type="l", lty=2)#
abline(h=log(0.5), lty=2)#
plotMIC(3, "Strain C", plotX=TRUE)#
abline(h=log(0.5), lty=2)#
mtext("MIC (fitness)", side=2, line=2.5, outer=TRUE)#
mtext(expression(paste("Fluconazole concentration (", mu, "g/mL)", sep="")), side=1, line=2, outer=TRUE)#
dev.off()#
system("open /Users/acgerstein/Documents/Postdoc/Research/Clinical_isolates/Carl/figures/MICResults.pdf")
pdf("/Users/acgerstein/Documents/Postdoc/Research/Clinical_isolates/Carl/figures/MICResultsDemo.pdf", width=6, height=5)#
plotMIC(1, "Strain A", plotX = TRUE)#
abline(h=log(4), lty=2)#
mtext("MIC (fitness)", side=2, line=3, outer=FALSE)#
mtext(expression(paste("Fluconazole concentration in medium (", mu, "g/mL)", sep="")), side=1, line=3, outer=FALSE)#
dev.off()#
system("open /Users/acgerstein/Documents/Postdoc/Research/Clinical_isolates/Carl/figures/MICResultsDemo.pdf")
pdf("/Users/acgerstein/Documents/Postdoc/Research/Clinical_isolates/Carl/figures/MICResultsFH-2.pdf", width=6, height=4)#
plot(log(sub2$FLC.level), log(sub2$MIC1), type="b", xaxt="n", yaxt="n", ylab="", xlab="", cex=1.5, ylim=c(log(0.25), log(280)), xlim=c(log(4), log(160)))#
axis(2, las=2, labels=c("0.125", "0.5", "2", "8", "32", "128", "256"), at=c(log(0.125), log(0.5), log(2), log(8), log(32), log(128), log(256)))#
axis(1, labels=c("0.5", "2", "8", "32", "128"), at=c(log(0.5), log(2), log(8), log(32), log(128)))#
mtext("MIC (fitness)", side=2, line=3, outer=FALSE)#
mtext(expression(paste("Fluconazole concentration in medium (", mu, "g/mL)", sep="")), side=1, line=3, outer=FALSE)#
dev.off()#
system("open /Users/acgerstein/Documents/Postdoc/Research/Clinical_isolates/Carl/figures/MICResultsFH-2.pdf")
?diff
load("/Users/acgerstein/Documents/Postdoc/Things from:for others/UMN/Ben/test.RData")
.RData
library(devtools)#
install_github("acgerstein/diskImageR")
library("diskImageR")
library(markdown)#
library(knitr)#
setwd("~/Documents/Postdoc/Research/diskImageR/vignettes/")
knit2html("Quantitative Disk Assay.Rmd")
browseURL("Quantitative Disk Assay.html")
browseURL("Quantitative Disk Assay.html")
knit2html("Quantitative Disk Assay.Rmd")
browseURL("Quantitative Disk Assay.html")
knit2html("Quantitative Disk Assay.Rmd")
browseURL("Quantitative Disk Assay.html")
knit2html("Quantitative Disk Assay.Rmd")
browseURL("Quantitative Disk Assay.html")
knit2html("Quantitative Disk Assay.Rmd")
browseURL("Quantitative Disk Assay.html")
knit2html("Quantitative Disk Assay.Rmd")
browseURL("Quantitative Disk Assay.html")
knit2html("Quantitative Disk Assay.Rmd")
browseURL("Quantitative Disk Assay.html")
?createDataframe
knit2html("Quantitative Disk Assay.Rmd")
browseURL("Quantitative Disk Assay.html")
knit2html("Quantitative Disk Assay.Rmd")
browseURL("Quantitative Disk Assay.html")
devtools::build("diskImageR")
dir()
setwd("..")
dir()
devtools::build("diskImageR")
setwd("..")
devtools::build("diskImageR")
devtools::build("diskImageR")
ls()
dir()
?install_github
install_github("acgerstein/diskImageR", build_vignettes = TRUE )
install_github("acgerstein/diskImageR", build_vignettes = TRUE )
install_github("acgerstein/diskImageR", local=FALSE)
ls()
vignette()
vignette
vignette("disk")
browseVignettes("diskImageR")
browseVignettes()
devtools::build()
setwd("diskImageR/")
devtools::build()
rmarkdown::render("Quantitative Disk Assay.Rmd")
dir()
setwd("vignettes/")
dir()
rmarkdown::render("Quantitative Disk Assay.Rmd")
rmarkdown::render("Quantitative Disk Assay.Rmd")
rmarkdown::render("Quantitative Disk Assay.Rmd")
rmarkdown::render("Quantitative Disk Assay.Rmd")
rmarkdown::render("Quantitative Disk Assay.Rmd")
rmarkdown::render("Quantitative Disk Assay.Rmd")
rmarkdown::render("Quantitative Disk Assay.Rmd")
rmarkdown::render("Quantitative Disk Assay.Rmd")
rmarkdown::render("Quantitative Disk Assay.Rmd")
rmarkdown::render("Quantitative Disk Assay.Rmd")
knit("Quantitative Disk Assay.Rmd")
markdownToHTML("diskImageR.md", "diskImageR.html")
markdownToHTML("Quantitative Disk Assay.md", "diskImageR.html")
---#
title: "Quantitative Disk Assay"#
author: "Aleeza C. Gerstein"#
date: "`r Sys.Date()`"#
output:#
	html_document:#
		toc: true#
		theme: united#
	pdf_document:#
		toc: true#
		highlight: zenburn#
vignette: >#
  %\VignetteIndexEntry{Quantitative Disk Assay}#
  %\VignetteEngine{knitr::rmarkdown}#
  \usepackage[utf8]{inputenc}#
---#
## Introduction to diskImageR#
#
diskImageR provides a quantitative way to analyze photographs taken from disk diffusion assays. diskImageR removes the need for subjective measurement by assessing zone diameter quantitatively from photographs taken of the disk diffusion plates. This method measures not only the zone of inhibition (i.e., resistance), but also how much growth there is above the zone of inhibition (tolerance), and the rate of change from no growth to full growth (sensitivity).#
<center>#
<img src="../inst/pictures/p2_30_a.JPG"  style="width: 40%; height: 40%" style="float:left," alt="" /> #
</center>#
#
## Prepare plates and photographs#
The analysis done by diskImageR will only be as good as your disk assay plates and the photographs you take. Plates should always be labelled on the side, not on the bottom. Care should be taken when setting up the camera to take photographs, as you want the lighting conditions to be as uniform as possible, without any shadows on the plates. Camera settings should be manual rather than automatic as much as possible. Once you have the set of photographs that you want to be analyzed together they should be placed in the same directory, with nothing else inside that directory.#
#
Photograph naming can be used downstream to have diskImageR do a number of statistical things (e.g., averaging across replicates, caulculations of variance, t-tests). The general format is "strain_factor1_factor2_rep.pdf". Conversely, if you intend to do all the statistical analysis later, photographs can be named anything, even numbered.#
#
Finally, photographs should be cropped carefully around the disk.#
#
<b> Important! </b> There can not be any spaces or special characters in any of the folder names that are in the path that will lead to your pictures or the directory that you will use as the main project folder (i.e., the place where all the output files from this package will go). #
#
## Run the imageJ macro on the set of photographs#
The first step in the diskImageR pipeline is to run the imageJ macro on the photograph directory. #
#
<b> Important! </b> imageJ must be installed on your computer. ImageJ is a free, public domain Java image proessing program available for download <a href="http://rsb.info.nih.gov/ij/download.html"> here</a>. Take note of the path to imageJ, as this will be needed for the first function.#
#
From each photograph, the macro (in imageJ) will automatically determine where the disk is located on the plate, find the center of the disk, and draw 40mm lines out from the center of the disk every 5 degrees. For each line, the pixel intensity will be determined at many points along the line. This data will be stored in the folder "imageJ-out" on your computer, with one file for each photograph.#
#
This step can be completed using one of two functions.#
```r#
#This function allows you to run the imageJ macro through a user-interface with pop-up boxes to select #
#where you want the main project directory to be and where to find the location of the photograph directory.#
runIJ("projectName")#
```#
#
```{r}#
#If you are more comfortable with R, and don't want to be bothered with pop-up boxes, use the #
#alternate function to supply the desired main project directory and photograph directory locations.#
runIJManual("vignette", projectDir= getwd(), pictureDir = file.path(.libPaths(), "diskImageR", "pictures", ""), imageJLoc = "loc2")#
```#
#
Depending on where imageJ is located, the script may not run unless you specify the filepath. See ?runIJ for more details.#
#
If you want to access the output of these functions in a later R session you can with#
```r#
readInExistingIJ("projectName") 	#can be any project name, does not have to be the same as previously used#
```#
#
### [optional] Plot the imageJ output#
To plot pixel intensity from the average from all photographs use#
```{r}#
plotRaw("vignette", savePDF=FALSE)#
```#
#
## Run the maximum likelihood analysis #
The next step is to use maximum likelihood to find the logistic and double logistic equations that best describe the shape of the imageJ output data. These data follow a characteristic "S-shape" curve, so the standard logistic equation is used where asym is the asymptote, od50 is the midpoint, and scal is the slope at od50 divided by asym/4.#
$$#
y = \frac{asym*exp(scal(x-od50))}{1+exp(scal(x-od50))}+N(0, \sigma)#
$$#
#
We often observed disk assays that deviated from the single logistic, either rising more linearly than expected at low cell density, or with an intermediate asymptote around the midpoint. To fascilitate fitting these curves, we fit a double logistic, which allows greater flexibility. Our primary goal in curve fitting is to capture an underlying equation that fits the observed data, rather than to test what model fits better.#
$$#
y = \frac{asymA*exp(scalA(x-od50A))}{1+exp(scalA(x-od50A))}+\frac{asymB*exp(scalB(x-od50B))}{1+exp(scalB(x-od50B))}+N(0, \sigma)#
$$#
#
From these functions we substract off the plate background intensity from all values; this is common across all pictures taken at the same time and is determined from the observed pixel intensity on a plate with a clear halo (specified by the user). We then use the parameters identified in the logistic equations to determine the resistance parameters.#
#
* <b>Resistance</b>#
	: asymA+asymB are added together to determine the maximum level of intensity (= cell density) achieved on each plate. The level of resistance (zone of inhibition, ZOI), is calculated by asking what x value (distance in mm) corresponds to the point where 80%, 50% and 20% reduction in growth occurs (corresponding to *ZOI80*, *ZOI50*, and *ZOI20*)#
* <b>Tolerance</b>#
	: the 'rollmean' function from the zoo package is used to calculate the area under the curve (AUC)  in slice from the disk edge to each ZOI cutoff. This achieved growth is then compared to the potential growth, namely, the area of a rectangle with length and height equal to the ZOI. The calculated paramaters are thus the fraction of full growth in this region (*fAUC80*, *fACU50*, *fAUC20*).#
* <b>Sensitivity</b>#
	: the ten data points on either side of the midpoint (od50) from the single logistic equation are used to find the slope of the best fit linear model using the lm function in R.#
#
```{r}#
maxLik("vignette", clearHalo=1, savePDF=FALSE, ZOI="all", needML=FALSE)#
```#
#
### [OPTIONAL] Save the maximum likelihood results#
It is possible to save the maximum likelihood results using#
```#
saveMLParam("vignette")#
```#
This will save a .csv file into the *paramter_files* directory that contains parameter estimates for asym, od50, scal and sigma, as well as the log likelihood of the single and double logistic models.#
## Output and save the results #
The last required step is to save a dataframe with the resistance parameter estimates. #
#
```{r}#
createDataframe("vignette", clearHalo = 1)#
vignette.df#
```
knit("Quantitative Disk Assay.Rmd")
markdownToHTML("diskImageR.md", "diskImageR.html")
markdownToHTML("Quantitative Disk Assay.md", "diskImageR.html")
markdownToPDF("Quantitative Disk Assay.md", "diskImageR.pdf")
render("Quantitative Disk Assay.Rmd", "QDA")
pandoc("Quantitative Disk Assay.md", format=latex'
")
)
"
)
'
pandoc("Quantitative Disk Assay.md", format=latex
)
pandoc("Quantitative Disk Assay.md", format="latex")
pandoc('Quantitative Disk Assay.md', format='latex')
dir()
require(knitr)#
  require(tools)#
  thedir <- file_path_as_absolute(dirname(fname))#
  thefile <- (basename(fname)) #
  create_latex <- function(f){#
    knit(f, 'tmp-outputfile.md'); #
    newname <- paste0(file_path_sans_ext(f), ".tex")#
    mess <- paste('pandoc -f markdown -t latex -s -o', shQuote(newname), #
                  "tmp-outputfile.md")#
    system(mess)#
    cat("The Latex file is", file.path(thedir, newname), #
        "\nIf transporting do not forget to include the folder", file.path(thedir, "figure"), "\n")#
    mess <- paste('rm tmp-outputfile.md')#
    system(mess)#
  }#
#
  create_word <- function(f){#
    knit(f, 'tmp-outputfile.md');#
    newname <- paste0(file_path_sans_ext(f),".docx")#
    mess <- paste('pandoc -f markdown -t docx -o', shQuote(newname), "tmp-outputfile.md")#
    system(mess)#
    cat("The Word (docx) file is", file.path(thedir, newname), "\n")#
    mess <- paste('rm tmp-outputfile.md')#
    system(mess)#
  }#
  create_html <- function(f){#
    knit2html(f)#
    cat("The main HTML file is", file.path(thedir, paste0(file_path_sans_ext(f), ".html")), #
        "\nIf transporting do not forget to include the folder", file.path(thedir, "figure"), "\n")#
  }#
#
  create_pdf <- function(f){#
    knit(f, 'tmp-outputfile.md');#
    newname <- paste0(file_path_sans_ext(f),".pdf")#
    mess <- paste('pandoc -f markdown -o', shQuote(newname), "tmp-outputfile.md")#
    system(mess)#
    cat("The PDF file is", file.path(thedir, newname), "\n")#
    mess <- paste('rm tmp-outputfile.md')#
    system(mess)#
  }#
#
  origdir <- getwd()  #
  tryCatch({#
    setwd(thedir) ## put us next to the original Rmarkdown file#
    out <- match.arg(output)#
    switch(out,#
      latex=create_latex(thefile),#
      html=create_html(thefile),#
      pdf=create_pdf(thefile),#
      word=create_word(thefile)#
    )}, finally=setwd(origdir))#
}
thedir <- file_path_as_absolute(dirname(fname))
library(tools)
library(knitr)
thedir <- file_path_as_absolute(dirname(fname))
?file_path_as_absolute
dir()
setwd("..")
dir()
source('rmd2.R')
source('rmdd.R')
source('rmd.R')
rmd.convert <- function(fname, output=c('latex', 'word', 'html', "pdf")){#
  ## Thanks to Robert Musk for helpful additions to make this run better on Windows#
#
  require(knitr)#
  require(tools)#
  thedir <- file_path_as_absolute(dirname(fname))#
  thefile <- (basename(fname)) #
  create_latex <- function(f){#
    knit(f, 'tmp-outputfile.md'); #
    newname <- paste0(file_path_sans_ext(f), ".tex")#
    mess <- paste('pandoc -f markdown -t latex -s -o', shQuote(newname), #
                  "tmp-outputfile.md")#
    system(mess)#
    cat("The Latex file is", file.path(thedir, newname), #
        "\nIf transporting do not forget to include the folder", file.path(thedir, "figure"), "\n")#
    mess <- paste('rm tmp-outputfile.md')#
    system(mess)#
  }#
#
  create_word <- function(f){#
    knit(f, 'tmp-outputfile.md');#
    newname <- paste0(file_path_sans_ext(f),".docx")#
    mess <- paste('pandoc -f markdown -t docx -o', shQuote(newname), "tmp-outputfile.md")#
    system(mess)#
    cat("The Word (docx) file is", file.path(thedir, newname), "\n")#
    mess <- paste('rm tmp-outputfile.md')#
    system(mess)#
  }#
  create_html <- function(f){#
    knit2html(f)#
    cat("The main HTML file is", file.path(thedir, paste0(file_path_sans_ext(f), ".html")), #
        "\nIf transporting do not forget to include the folder", file.path(thedir, "figure"), "\n")#
  }#
#
  create_pdf <- function(f){#
    knit(f, 'tmp-outputfile.md');#
    newname <- paste0(file_path_sans_ext(f),".pdf")#
    mess <- paste('pandoc -f markdown -o', shQuote(newname), "tmp-outputfile.md")#
    system(mess)#
    cat("The PDF file is", file.path(thedir, newname), "\n")#
    mess <- paste('rm tmp-outputfile.md')#
    system(mess)#
  }#
#
  origdir <- getwd()  #
  tryCatch({#
    setwd(thedir) ## put us next to the original Rmarkdown file#
    out <- match.arg(output)#
    switch(out,#
      latex=create_latex(thefile),#
      html=create_html(thefile),#
      pdf=create_pdf(thefile),#
      word=create_word(thefile)#
    )}, finally=setwd(origdir))#
}
dir()
setwd("vignettes/")
rmd.convert('Quantitative Disk Assay.Rmd', 'latex') ## for a latex document
rmd.convert('Quantitative Disk Assay.Rmd', 'html') ## for a latex document
pandoc("Quantitative Disk Assay.md", format = "pdf")
pandoc("Quantitative Disk Assay.md", format = "html")
dir()
knit2html("Quantitative Disk Assay.Rmd")
browseURL("Quantitative Disk Assay.html")
knit2html("Quantitative Disk Assay.Rmd")
browseURL("Quantitative Disk Assay.html")
knit2html("Quantitative Disk Assay.Rmd")
browseURL("Quantitative Disk Assay.html")
knit2html("Quantitative Disk Assay.Rmd")
browseURL("Quantitative Disk Assay.html")
knit2html("Quantitative Disk Assay.Rmd")
browseURL("Quantitative Disk Assay.html")
knit2html("Quantitative Disk Assay.Rmd")
browseURL("Quantitative Disk Assay.html")
knit2html("Quantitative Disk Assay.Rmd")
browseURL("Quantitative Disk Assay.html")
knit2html("Quantitative Disk Assay.Rmd")
browseURL("Quantitative Disk Assay.html")
knit2html("Quantitative Disk Assay.Rmd")
browseURL("Quantitative Disk Assay.html")
knit2html("Quantitative Disk Assay.Rmd")
browseURL("Quantitative Disk Assay.html")
knit2html("Quantitative Disk Assay.Rmd")
browseURL("Quantitative Disk Assay.html")
knit2html("Quantitative Disk Assay.Rmd")
browseURL("Quantitative Disk Assay.html")
knit2html("Quantitative Disk Assay.Rmd")
browseURL("Quantitative Disk Assay.html")
graphics.off()
library(devtools)#
install_github("acgerstein/diskImageR")
library("diskImageR")#
library(markdown)#
library(knitr)#
setwd("~/Documents/Postdoc/Research/diskImageR/vignettes/")
knit2html("Quantitative Disk Assay.Rmd")
browseURL("Quantitative Disk Assay.html")
library("diskImageR")
?maxLik
install_github("acgerstein/diskImageR")
library(devtools)
install_github("acgerstein/diskImageR")
library("diskImageR")#
library(markdown)#
library(knitr)#
setwd("~/Documents/Postdoc/Research/diskImageR/vignettes/")#
knit2html("Quantitative Disk Assay.Rmd")
?maxLik
